---
title: 从51到32
date: 2023-07-08 09:52:35
tags: 从51到32
---

## c语言程序入门应用

### 关键字与数据类型
![image](/img/2023-07-08101610.png)

#include => 包含头文件  
**头文件预处理在源文件与编译器之间**  
#define => 宏定义  
一般在头部，将c中某关键字进行替换


![ima](/img/20230708102636.jpg)
>32个关键字，编译器预先定义了有一定物理意义的字符串 =>不同编译器有不>同的定义sizeof 也是关键字:查看变量在内存空间中容量的工具，用法sizeof(变量)通>过关键字定义的不同数据类型的变量，限制变量 (资源)的大小(e.g.4字节，2字节...)

![imag](/img/2023-07-08102810.png)

c中的数据类型有明确规范，无论输入还是输出都要标明

>    %d 十进制有符号整数  
>    %u 十进制无符号整数  
>    %f 浮点数  
>    %s 字符串  
>    %c 单个字符  
>    %p 指针的值  
>    %e 指数形式的浮点数  
>    %x, %X 无符号以十六进制表示的整数  
>    %o 无符号以八进制表示的整数  
>    %g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出  
>    %p 输出地址符  
>    %lu 32位无符号整数  
>    %llu 64位无符号整数  
>    %% 输出百分号字符本身。  
>    除了格式化说明符之外，printf() 函数还支持一些标志和选项，用于控制输出的精度、宽度、填充字符和对齐方式等。  例如：

>    %-10s：左对齐并占用宽度为 10 的字符串；
>    %5.2f：右对齐并占用宽度为 5，保留两位小数的浮点数；
>    %#x：输出带有 0x 前缀的十六进制数。


### 局部变量、全局变量、静态变量
对于单一文件而言的:局部变量、全局变量、静态变量
>局部变量:定义在函数内部的变量=>代码块作用域
>全局变量:定义在函数外部的变量=>文件作用域
>静态变量:有static修饰的变量
有很多种组合，不需要都搞清楚，等遇到了再分析: where (可见性)?& static (生命周期)?

下面这个例子很好的展示了这一点并且展示了冒泡排序
**示例**
``` c
#include<stdio.h>

int main()
{
    int class[10];
    for (int i = 0; i < 10; i++) // 循环输入10次
    {
        scanf("%d",&class[i]);
    }
    printf("你输入了：");
    for (int j = 0; j < 10; j++) //遍历数组并输出
    {
        printf("%d ",class[j]);
    }
    for (int i = 0; i < 10; i++) //冒泡排序
    {
        for (int j = 0; j < 10; j++)
        {
            if (class[j+1]>class[j])
            {
                int null = class[j];
                class[j] = class[j+1];
                class[j+1] = null;
            }
        }
    }
    printf("\n");
    for (int j = 0; j < 10; j++) //遍历排序好的数组并输出
    {
        printf("排第%d的数是%d\n",j+1,class[j]);
    }
    
}
```


### 数组

例：char a[]:{}

**当char中使用中文时，应该是二维数组**
```bash
char wday[7][7] = {"星期一","星期二","星期三","星期四","星期五","星期六","星期天"};
```

**注意事项**
>int a[]={.....}; 可以在定义的时候给出初始值。可省略。 int b[][5]={...}; 同上，但是第二个不能省略。 a[]=3; 这样做就不对了，里面没有定位，不能省略。 b[][2]=2; 同上，不能省略。 a[x]=3；这样做也对，但是要保证变量x的值正确。C不会自动给你查越界。


**以下例子很好的展示数组**
``` c
#include <stdio.h>

void  main()
{
    int tick = 0; //0~86399
    short mouth[12] = {31,29,31,30,31,30,31,31,30,31,30,31}; 
    short date; 
    short yue;
    short week; 
    char wday[][7] = {"星期一","星期二","星期三","星期四","星期五","星期六","星期天"};
    printf("请输入一个在 1~366 区间的数\n");
    scanf_s("%d", &tick); 
    week =  (tick+8)%7 ; //这个应该不会错的
    date = tick;
    for (int i = 0; i < 12; i++)  //依次遍历，一旦小于等于0，则该次遍历为月份
    {
      tick = tick - mouth[i];
      if (tick<=0){yue=i+1;break;};
    }
    for (int j = 0; j < yue; j++) //遍历之后获得减掉前面月份天数的值，即为当月日期
    {
      date= date-mouth[j-1];
    }
    printf("当前日期为: 20-%02d-%02d-%s\n", yue, date, wday[week]);  
}
```
### 枚举

说实话还是不太理解

枚举方法：

1、先定义枚举类型，再定义枚举变量
``` c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
enum DAY day;
```
这里的DAY是枚举名

2、定义枚举类型的同时定义枚举变量
``` c
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```

3、省略枚举名称，直接定义枚举变量
``` c
enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
```
可以使用typedef定义别名
``` c
typedef enum
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
} day;
day day1 day2;
```
其中day是这个枚举名的别名，提高代码可读性

下面这串代码很好的展示了枚举的应用

``` c
#include <stdio.h>
 
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
 
int main()
{
    enum DAY day;
    day = WED;
    printf("%d",day);
    return 0;
}
```

**枚举经常与switch一同使用**
下面的代码展示了这种情况
``` c
#include <stdio.h>
#include <stdlib.h>
int main()
{
 
    enum color { red=1, green, blue };
 
    enum  color favorite_color;
 
    /* 用户输入数字来选择颜色 */
    printf("请输入你喜欢的颜色: (1. red, 2. green, 3. blue): ");
    scanf("%u", &favorite_color);
 
    /* 输出结果 */
    switch (favorite_color)
    {
    case red:
        printf("你喜欢的颜色是红色");
        break;
    case green:
        printf("你喜欢的颜色是绿色");
        break;
    case blue:
        printf("你喜欢的颜色是蓝色");
        break;
    default:
        printf("你没有选择你喜欢的颜色");
    }
 
    return 0;
}
```
**补充**
>在所有教科书与c规范中，switch都是不允许case后接范围的，但是GNU C进行了扩展
>可以使用case min ... max这种用法表示范围（英文句号，前后有空格）

示例
``` c
#include<stdio.h>

int main(){
    int i;
    scanf( "%d",&i);
    switch (i)
    {
    case 1 ... 3:
        printf("niubi\n");
        break;
    
    default:
        break;
    }
}
```

### 指针

C语言中几乎最重要的地方来了，难度较大，必须掌握

#### 指针是什么
``` c
#include <stdio.h>
 
int main ()
{
    int var_runoob = 10;
    int *p;              // 定义指针变量
    p = &var_runoob;
 
   printf("var_runoob 变量的地址： %p\n", p);
   return 0;
}
```

![image](/img/c-pointer.png)

&取址*取值
![image](/img/20230710103743.png)

**数组名即指针！！**
![image](/img/20230710105357.png)

指针控制数组
![image](/img/20230710110332.png)

#### 数组与指针
关于指针，内含的奥妙非常多，其中非常知名的就是数组即指针  
**数组是指针的另一种表示**  
我们可以这么看：
~~~c
int main()
{
    char a[3]= "123";
    printf("%c",*(a+2));
}
~~~
在这里面定义了一个字符串数组，但是我调用他的方式却是使用了指针  
数组名就是一个指针常量，这里**a**的值是数组a[3]的首元素的地址  
于是，我们可以这样：
```c
int main()
{
    char *a = "123";
    printf("%c",a[2]);
}
```
与上面的代码并不会出现差别

#### 多重指针
可以定义一个指向指针的指针
```c
int main()
{
    int a = 1;
    int *p = &a;
    int **p2 = &p;
}
```
以此为准可以不断叠加指针，完成许多复杂的功能

### 结构体

与枚举有点相似
为了使有关联性的变量变得更加易控，也为了提高可读性，结构体因此而生

结构体定义
```c
struct  Stuructstudent{
    int num;
    char name;
    char sex;
    int age
};//声明结构体
Structstudent student1;//定义变量
```
>实际上结构体就是一种数据类型，只不过是由程序员自己定义的
>在实际生活中，我们会有各种各样的数据类型，如图书的名、ISBN、价格等可以集合为一个数据类型

```c
int main()
{
    struct book{
        int isbn;
        char name[10];
        double price;
    };
    book b3= {"活着",111111111,39};
}
```

**注意**
>需要注意的是，结构体中内存的分配是由结构体的中定义的变量占用的内存决定的
>但是但是它却遵循整除内存原则，如上述的代码中
>首先，计算机会找到一个可以被4（int的长度）整除的内存地址（如2000）
>然后在2004后面找到可以被10（name数组的长度）整除的地址（如2010）
>最后在在2020后面找到可以被8（double的长度）整除的地址（如2024）
>最后还要将首末相连空隙进行填充，一共是32字节的长度，整体的长度还必须是结构里最大数据类型的长度的整数倍（这里是double的长度8的整数倍）
>如果不是还要在后面进行填充（假如是36，就要填充到40）
>所以在结构体中数据类型的定义的先后十分重要
>在上述代码中只需要将isbn和name调换顺序就只需要24字节的空间   



## 51单片机

### 硬件设备与软件环境

**单片机**
- stc89c52rc  

**软件环境**
- [Visual studio code + Embedded IDE + keil c]()  
(点击跳转部署教程)
**外设**
- 按钮*3
- 4位数码管*1
- led*4
- 蜂鸣器*1
- 看门狗*1
- 12mhz晶振
- usbin

**注意**
>看芯片手册是一个非常重要的习惯
>我们做的无非就是复现手册的内容而已
>此篇章只保留作者认为重要的单片机知识

### IO口的使用

无需多言，上代码
```c
#include <REG52.H>
#include "Delay.h"

sbit led1=P2^4;
sbit led2=P2^5;
sbit led3=P2^6;
sbit led4=P2^7;

void main()
{
    while(1){
        led1 = 0;
        Delay(500);
        //led1 = 1;
        led2 = 0;
        Delay(500);
        //led2 = 1;
        led3 = 0;
        Delay(500);
        //led3 = 1;
        led4 = 0;
        Delay(500);
        //led4 = 1;				
        led1 = 1;
        Delay(500);
        //led1 = 1;
        led2 = 1;
        Delay(500);
        //led2 = 1;
        led3 = 1;
        Delay(500);
        //led3 = 1;
        led4 = 1;
        Delay(500);
        //led4 = 1;
    }
	
}
```
这是最简单的led流水灯效果，所有入门51的必备
IO口的控制流程如下
1.查看需要控制的外设的对应单片机的引脚
2.使用sbit定义引脚名（如led1）
3.为引脚编写1或0来控制引脚

### 按键的防抖

我甚至不知道要不要给它单独开一个章节  

>我们使用按钮的时候一般使用判断  
```c
while(1){
    if（key1 == 1）{
        //代码区
    }
}
```
>然而造成的结果是，我们明明只想要一次运行，但是由于单片机速度太快，会造成非常多次运行
>因此，我们需要防抖
```c
while(1){
    if(key1 == 1){
        delay(20);//延迟看个人而定
        if(key1 == 1){
        //代码区
        }
    }
}
```
只需要一个简单延迟函数就完成了防抖

**注意**
>不过，在较为大的工程中，延迟非常容易造成工程总体运行的堵塞情况
>同时，延迟也无法很好的避免多次运行的问题
>因此，在后续的工程开发中我们使用外部中断来实现按钮功能
>外部中断是异步的（异步是计算机与电子信息中非常重要的概念）

### 数码管显示

数码管实现原理：请回顾数字电路技术课程

无需多言，上代码

```c
#include <REGX52.H>
#include "Delay.h"

sbit key1=P3^2;
sbit key2=P3^3;
sbit key3=P3^4;

//数码管段码表
unsigned char NixieTable[]={0x03,0x9F,0x25,0x0D,0x99,0x49,0x41,0x1F,0x01,0x09};



//数码管显示子函数
void Nixie(unsigned char Location,Number)
{
	
		switch(Location)		//位码输出
	{
		case 1:P2=0x7;break;
		case 2:P2=0xB;break;
		case 3:P2=0xD;break;
		case 4:P2=0xE;break;
	}
	P0=NixieTable[Number];	//段码输出
	Delay(1);				//显示一段时间
	P0=~0x0;				//段码清0，消影
}

void main()
{
		unsigned char x = 0;
		unsigned char y = 0;
		unsigned char z = 0;
	while(1)
	{
		if(key1 ==0)
		{
			Delay(80);
			if(key1 == 0)
			{
				x++;
				if(x>9)
				{
					x = 0;
					y++;
					if(y>9)
					{
						y=0;
						z++;
					}
				}
			}
		}
		Nixie(1,1);		//在数码管的第1位置显示1
//		Delay(20);
		Nixie(2,2);		//在数码管的第2位置显示2
//		Delay(20);
		Nixie(3,3);		//在数码管的第3位置显示3
//		Delay(20);
		Nixie(4,4);		//在数码管的第4位置显示4
//		Delay(20);
	}
}
```
**流程**
1.弄清楚每个数字对应在数码管上的位置
2.位置的二进制表示
3.二进制转16进制
4.每一个数码管的启动方式（需让其他数码管关，否则出现全亮，使用延迟实现单独亮）
5.打包成函数，方便调用