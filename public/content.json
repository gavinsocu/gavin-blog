{"meta":{"title":"gavinsocu","subtitle":"","description":"gavin的博客","author":"gavinccc","url":"http://blog.gavinccc.com","root":"/"},"pages":[{"title":"","date":"2024-02-26T08:38:12.947Z","updated":"2024-02-26T08:38:12.947Z","comments":false,"path":"artitalk/index.html","permalink":"http://blog.gavinccc.com/artitalk/index.html","excerpt":"","text":""},{"title":"","date":"2024-02-26T08:38:12.947Z","updated":"2024-02-26T08:38:12.947Z","comments":false,"path":"about/index.html","permalink":"http://blog.gavinccc.com/about/index.html","excerpt":"","text":"我的经历似乎可以写不少，然而都是些提上来的小事，无言无言"},{"title":"","date":"2024-02-26T08:38:12.948Z","updated":"2024-02-26T08:38:12.948Z","comments":true,"path":"custom/darkmode.js","permalink":"http://blog.gavinccc.com/custom/darkmode.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); volantis.dark.push(switchNightMode);"},{"title":"Myfriends","date":"2024-02-26T08:38:12.948Z","updated":"2024-02-26T08:38:12.948Z","comments":false,"path":"friends/index.html","permalink":"http://blog.gavinccc.com/friends/index.html","excerpt":"感恩","text":"感恩"},{"title":"","date":"2024-02-26T08:38:12.948Z","updated":"2024-02-26T08:38:12.948Z","comments":true,"path":"custom/binft.js","permalink":"http://blog.gavinccc.com/custom/binft.js","excerpt":"","text":"var binft = function (r) { var isTransparent = true; function getRandomColor() { if(isTransparent){ isTransparent = false; //此处修改字体颜色,最后的 0 和 1 不要改 return \"rgba(255,255,255,0)\" }else{ isTransparent = true; return \"rgba(255,255,255,1)\" } } function n(r) { for (var n = document.createDocumentFragment(), i = 0; r > i; i++) { var oneword = document.createElement(\"span\"); oneword.textContent = \"_\"; // 此处是末尾字符,如果想用光标样式可以改为\"|\" oneword.style.color = getRandomColor(); n.appendChild(oneword); } return n } function i() { var t = wordList[c.skillI]; c.step ? c.step-- : (c.step = refreshDelayTime, c.prefixP < l.length ? (c.prefixP >= 0 && (c.text += l[c.prefixP]), c.prefixP++) : \"forward\" === c.direction ? c.skillP < t.length ? (c.text += t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction = \"backward\", c.delay = showTotalWordDelayTime) : c.skillP > 0 ? (c.text = c.text.slice(0, -1), c.skillP--) : (c.skillI = (c.skillI + 1) % wordList.length, c.direction = \"forward\")), r.textContent = c.text, r.appendChild(n(c.prefixP < l.length ? Math.min(maxLength, maxLength + c.prefixP) : Math.min(maxLength, t.length - c.skillP))), setTimeout(i, d) } var l = \"\", //此处改成你自己的诗词 wordList = [ \"欲买桂花同载酒,终不似,少年游\", \"休对故人思故国,且将新火试新茶,诗酒趁年华\", \"仰天大笑出门去,我辈岂是蓬蒿人\", \"才见岭头云似盖,已惊岩下雪如尘\", \"人间万事消磨尽,只有清香似旧时\", \"日暮酒醒人已远,满天风雨下西楼\", \"落灯花,棋未收,叹新丰逆旅淹留\", \"软风吹过窗纱,心期便隔天涯\", \"迷惑失故路,薄暮无宿栖\", \"旧时王谢堂前燕,飞人寻常百姓家\", \"晓迎秋露一枝新,不占园中最上春\", \"荷尽已无擎雨盖,菊残犹有傲霜枝\", \"山涤余霭,宇暧微霄.有风自南,翼彼新苗\", \"江东子弟多才俊,卷土重来未可知\", \"莫听穿林打叶声,何妨吟啸且徐行\", \"人生若只如初见,何事秋风悲画扇\", ].map(function (r) { return r + \"\" }), showTotalWordDelayTime = 2, refreshDelayTime = 1, maxLength = 1, d = 75, c = { text: \"\", prefixP: -maxLength, skillI: 0, skillP: 0, direction: \"forward\", delay: showTotalWordDelayTime, step: refreshDelayTime }; i() }; binft(document.getElementById('binft'));"},{"title":"","date":"2024-02-26T08:38:12.948Z","updated":"2024-02-26T08:38:12.948Z","comments":true,"path":"custom/darkmode.css","permalink":"http://blog.gavinccc.com/custom/darkmode.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"所有分类","date":"2024-02-26T08:38:12.947Z","updated":"2024-02-26T08:38:12.947Z","comments":true,"path":"categories/index.html","permalink":"http://blog.gavinccc.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-02-26T08:38:13.052Z","updated":"2024-02-26T08:38:13.052Z","comments":true,"path":"tags/index.html","permalink":"http://blog.gavinccc.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-02-26T08:38:12.948Z","updated":"2024-02-26T08:38:12.948Z","comments":true,"path":"htmll/renwu.html","permalink":"http://blog.gavinccc.com/htmll/renwu.html","excerpt":"","text":"作业 点一下 function jis(){ setTimeout(function(){ document.getElementById(\"bb\").className='jianbian' },10000) } function abc(){ var x=document.getElementById(\"ddd\") var a=\"\" a=Math.floor(Math.random()*900)+100; document.getElementById(\"ccc\").innerHTML=a if(a>600){ x.innerHTML=\"中奖啦！！！\" }else{ x.innerHTML=\"\" } } *{ margin: 0; padding: 0; } #bb{ width: 100%; height: 814px; margin: 0px auto; text-align: center; } button{ font-size: 20px; color: black; width: 100px; height: 30px; margin-top: 10%; background-image: linear-gradient(to left, #f1aee4, #d7baf4, #bfc5fa, #aecef7, #a9d4ee); border-radius: 2px; border: 2px; border-color: black; } .xuanfu:hover{ box-shadow: 0 12px 16px 0 rgba(0,0,0,0.24),0 17px 50px 0 rgba(0,0,0,0.19); } #ccc{ font-size: 300px; } .jianbian{ background-image: linear-gradient(to right top, #e79bc6, #c98ebf, #aa82b6, #8b77aa, #6c6b9c, #586c9c, #436d9a, #2a6d95, #017a9b, #00869d, #00929b, #159d94); }"},{"title":"","date":"2024-02-26T08:38:13.051Z","updated":"2024-02-26T08:38:13.051Z","comments":true,"path":"message/index.html","permalink":"http://blog.gavinccc.com/message/index.html","excerpt":"","text":"留言板"},{"title":"","date":"2024-02-26T08:38:13.051Z","updated":"2024-02-26T08:38:13.051Z","comments":true,"path":"mylist/index.html","permalink":"http://blog.gavinccc.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"yolo多卡训练卡死(pytorch)","slug":"yoloTrainingStuck (pytorch)","date":"2025-07-15T13:36:21.000Z","updated":"2025-07-15T14:30:45.496Z","comments":true,"path":"2025/07/15/yoloTrainingStuck (pytorch)/","permalink":"http://blog.gavinccc.com/2025/07/15/yoloTrainingStuck%20(pytorch)/","excerpt":"请忽略文章封面配图的带nvlink的多卡，实际情况是无nvlink，有nvlink的多卡该教程不奏效","text":"请忽略文章封面配图的带nvlink的多卡，实际情况是无nvlink，有nvlink的多卡该教程不奏效 本人在2024年第一次使用RTX 4090 + TITAN RTX 双卡训练yolo时出现卡死的情况（初始化阶段） 经过大量检索找到了解决办法来源：https://github.com/Megvii-BaseDetection/YOLOX/issues/1289#issuecomment-1409988436 仅允许IP套接字通信训练前在终端输入： 123export NCCL_LL_THRESHOLD=0export NCCL_P2P_DISABLE=1export NCCL_IB_DISABLE=1 也可以写入python脚本（使用os，问ai）NCCL_P2P_DISABLE 变量禁用点对点 （P2P） 传输，该传输使用 NVLink 或 PCI 在 GPU 之间使用 CUDA 直接访问。NCCL_IB_DISABLE 变量禁用 NCCL 要使用的 IB&#x2F;RoCE 传输。相反，NCCL 将回退到使用 IP 套接字。 解释对于分布式训练，子进程始终被初始化dist.init_process_group由TCP 协议控制因此，仅使用 IP 通信似乎是合理的。 警告NCCL_LL_THRESHOLD 通常设置为零。可能会影响模型性能。https://github.com/NVIDIA/nccl/issues/369#issue-678319427 建议：多卡训练尽量显存相同，同时性能差距尽量小，否则影响速度和训练性能 –&gt;end 如果这帮助了你，可以对提出该解决方法的作者star or follow https://github.com/ZXYFrankIf this helps you, you can star or follow the author who proposed the solution","categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://blog.gavinccc.com/tags/pytorch/"},{"name":"nccl","slug":"nccl","permalink":"http://blog.gavinccc.com/tags/nccl/"},{"name":"yolo","slug":"yolo","permalink":"http://blog.gavinccc.com/tags/yolo/"}]},{"title":"Linux环境下常用的代理配置","slug":"Common_proxy_configurations_in_Linux_environment","date":"2025-01-17T11:38:19.000Z","updated":"2025-01-17T14:22:44.572Z","comments":true,"path":"2025/01/17/Common_proxy_configurations_in_Linux_environment/","permalink":"http://blog.gavinccc.com/2025/01/17/Common_proxy_configurations_in_Linux_environment/","excerpt":"本教程部分代理只适用于Ubuntu系统","text":"本教程部分代理只适用于Ubuntu系统 Linux环境下常用的代理配置此教程包含全局、用户、git、docker等代理设置 全局代理设置本人最常用的代理设置，基本上可以接管除了git、docker等部分不走正常网络协议之外的所有网络请求 1.编辑&#x2F;etc&#x2F;environment 1sudo nano /etc/environment 2.在该文件中添加代理配置添加以下行： 12http_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot;https_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 12http_proxy=&quot;http://192.168.10.88:10808&quot;https_proxy=&quot;http://192.168.10.88:10808&quot; nano编辑器的保存是ctrl+s或者ctrl+o退出是ctrl+x 3.最后source一下 1source /etc/environment 临时代理设置有的时候我们并不想一直开着代理，使用到代理的次数也屈指可数，这个时候我们可以选择单独终端配置临时代理甚至有的时候全局代理无法生效的时候使用这种方式也有奇效 直接在终端输入: 12export http_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot;export https_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 12export http_proxy=&quot;http://192.168.10.88:10808&quot;export https_proxy=&quot;http://192.168.10.88:10808&quot; 用户代理设置有的时候，我们只能为或只需为用户设置代理，这个时候就可以设置用户代理了(实际上用户代理只是临时代理的持久化) 1.打开~&#x2F;.bashrc文件 1nano ~/.bashrc 2.在该文件中添加代理配置 添加以下行： 12export http_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot;export https_proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 12export http_proxy=&quot;http://192.168.10.88:10808&quot;export https_proxy=&quot;http://192.168.10.88:10808&quot; 3.source一下 1source ~/.bashrc ubuntu图像界面GUI设置方式 1.点开设置–&gt;2.点击网络设置–&gt;3.点击设置代理–&gt;4.配置你的代理服务器和端口–&gt;保存即可 chrome浏览器代理设置(edge同样适用)1.点开浏览器扩展界面 2.在扩展市场搜索switchyomega并下载 3.将其变得可见 4.进入配置 选择协议配置服务器与端口：配置完就可以使用了 5.随时切换 还可以创建多个来随时切换不同的代理，也可以切回系统本来的网络 git设置代理两行命令的事 12git config --global http.proxy http://&lt;proxy-server&gt;:&lt;port&gt;git config --global https.proxy http://&lt;proxy-server&gt;:&lt;port&gt; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 12git config --global http.proxy http://192.168.10.88:10808git config --global https.proxy http://192.168.10.88:10808 不加gobal就是单个仓库，加了就是全局(用户全局) 想要去文件操作的记住配置文件是~&#x2F;.gitconfig apt设置代理其实如果已经配置了全局代理的一般都可以接管apt了，但是还是教一下 1.编辑&#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;proxy.conf(或&#x2F;etc&#x2F;environment) 1sudo nano /etc/apt/apt.conf.d/proxy.conf 2.在该文件中添加代理配置添加以下行： 12Acquire::http::proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot;Acquire::https::proxy=&quot;http://&lt;proxy-server&gt;:&lt;port&gt;&quot; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 12Acquire::http::proxy=&quot;http://192.168.10.88:10808&quot;Acquire::http::proxy=&quot;http://192.168.10.88:10808&quot; 3.最后source一下 1source /etc/apt/apt.conf.d/proxy.conf apt换源1.编辑&#x2F;etc&#x2F;apt&#x2F;sources.list 1sudo nano /etc/apt/sources.list 2.在该文件中添加清华源配置添加以下行： 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 3.最后更新一下 1sudo apt-get update docker设置代理1.创建文件夹&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d 1sudo mkdir /etc/systemd/system/docker.service.d 2.编辑&#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d&#x2F;proxy.conf文件 1sudo nano sudo mkdir /etc/systemd/system/docker.service.d/proxy.conf 输入以下行： 123[Service] Environment=&quot;HTTP_PROXY=代理服务器ip:port&quot; Environment=&quot;HTTPS_PROXY=代理服务器ip:port&quot; 假如你的代理服务器及其端口是192.168.10.88:10808则输入为： 123[Service] Environment=&quot;HTTP_PROXY=192.168.10.88:10808&quot; Environment=&quot;HTTPS_PROXY=192.168.10.88:10808&quot; 3.重启docker 12sudo systemctl daemon-reload #重启daemon进程sudo systemctl restart docker #重启docker 4.验证 1docker info 在长串info信息中如果出现类似下文的内容：HTTP Proxy: 代理服务器ip:portHTTPS Proxy: 代理服务器ip:port 说明你成功了，现在拉取镜像就是走的代理的 python设置清华源在pip install &lt;依赖包&gt;后面加上 -i https://pypi.tuna.tsinghua.edu.cn/simple 假如下载numpy 1pip install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.gavinccc.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.gavinccc.com/tags/ubuntu/"}]},{"title":"Ubunutu22.04安装ros1的一些流程和错误解决","slug":"Ubunutu22-04_install_ros1","date":"2025-01-10T14:40:28.000Z","updated":"2025-01-10T15:15:30.533Z","comments":true,"path":"2025/01/10/Ubunutu22-04_install_ros1/","permalink":"http://blog.gavinccc.com/2025/01/10/Ubunutu22-04_install_ros1/","excerpt":"其实x86版本的网络上还是有一堆一键安装脚本的，但是我遇到了必须使用arm的场景","text":"其实x86版本的网络上还是有一堆一键安装脚本的，但是我遇到了必须使用arm的场景 Ubunutu22.04安装ros1（arm版本） ubuntu22.04如何安装ros1为了避免墙的问题，建议直接开全局代理或者用户代理怎么开这里就不教了 添加ros源由于ROS1官网不支持，因此只能添加ROS2的源 12345sudo apt update &amp;&amp; sudo apt install curlsudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpgecho &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release &amp;&amp; echo $UBUNTU_CODENAME) main&quot; | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null sudo apt update 安装编译依赖123sudo apt-get install python3-rosdep python3-rosinstall-generator python3-vcstools python3-vcstool build-essentialsudo pip3 install -U rosdep rosinstall_generator vcstoolsudo pip3 install --upgrade setuptools 新建catkin workspace12mkdir ~/ros_catkin_wscd ~/ros_catkin_ws 拉取ROS Noetic源码123rosinstall_generator desktop --rosdistro noetic --deps --tar &gt; noetic-desktop.rosinstallmkdir ./srcvcs import --input noetic-desktop.rosinstall ./src 这里的第一步容易遇到拒绝访问的报错，所以还是尽快开代理就好了，第三步也容易被墙，代理！！！！！ 手动安装ROS Noetic依赖1sudo apt install libboost-all-dev uuid-dev python3-nose google-mock libgtest-dev libbz2-dev libgpgme-dev libssl-dev python3-coverage libboost-program-options-dev python3-psutil python3-opengl python3-pygraphviz python3-pydot qt5-qmake sbcl libapr1-dev libaprutil1-dev libboost-regex-dev liblog4cxx-dev python3-matplotlib libpyside2-dev libshiboken2-dev pyqt5-dev python3-pyqt5 python3-pyqt5.qtsvg python3-pyside2.qtsvg python3-sip-dev shiboken2 lm-sensors graphviz python3-paramiko python3-pycryptodome python3-gnupg python3-defusedxml python3-pyqt5.qtopengl libcurl4-openssl-dev libpoco-dev libogre-1.9-dev libassimp-dev libogre-1.9.0v5 libyaml-cpp-dev libgl1-mesa-dev libglu1-mesa-dev libqt5opengl5 libqt5opengl5-dev libopencv-dev python3-opencv python3-pykdl tango-icon-theme liborocos-kdl-dev libtinyxml-dev libtinyxml2-dev liburdfdom-headers-dev python3-numpy python3-empy libboost-filesystem-dev libboost-thread-dev python3-pygraphviz python3-pygraphviz python3-mock libboost-date-time-dev libboost-system-dev liburdfdom-dev libboost-chrono-dev libboost-dev libqt5core5a libqt5gui5 libqt5widgets5 qtbase5-dev libconsole-bridge-dev liblz4-dev python3-pyqt5.qtwebkit exfatprogs 遇到冲突就一个一个解决吧 编译（终于，这里会遇到非常非常多的问题！）编译编译命令： 1./src/catkin/bin/catkin_make_isolated --install -DCMAKE_BUILD_TYPE=Release -DPYTHON_EXECUTABLE=/usr/bin/python3 这里会编译184个包，如果编译成功第6点后面就不用看了。 错误解决 catkin问题 这个是setuptools版本的问题 解决方法：下载64版本 1pip install setuptools==64 还有可能会遇到与ros2环境冲突问题 解决方法：卸载ros2的环境变量 1unset ROS_DISTRO rosconsole问题 12345678910111213141516171819Errors &lt;&lt; rosconsole:make /home/youliang/ros_ws/build/catkin_ws/logs/rosconsole/build.make.002.log /home/youliang/ros_ws/build/catkin_ws/src/rosconsole/src/rosconsole/impl/rosconsole_log4cxx.cpp: In function ‘void ros::console::impl::initialize()’:/home/youliang/ros_ws/build/catkin_ws/src/rosconsole/src/rosconsole/impl/rosconsole_log4cxx.cpp:169:23: error: cannot convert ‘ros::console::impl::ROSConsoleStdioAppender*’ to ‘log4cxx::AppenderPtr’ &#123;aka ‘std::shared_ptr&lt;log4cxx::Appender&gt;’&#125; 169 | logger-&gt;addAppender(new ROSConsoleStdioAppender); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~ | | | ros::console::impl::ROSConsoleStdioAppender*In file included from /usr/include/log4cxx/spi/loggingevent.h:28, from /usr/include/log4cxx/layout.h:29, from /usr/include/log4cxx/appenderskeleton.h:28, from /home/youliang/ros_ws/build/catkin_ws/src/rosconsole/src/rosconsole/impl/rosconsole_log4cxx.cpp:42:/usr/include/log4cxx/logger.h:144:60: note: initializing argument 1 of ‘virtual void log4cxx::Logger::addAppender(log4cxx::AppenderPtr)’ 144 | virtual void addAppender(const AppenderPtr newAppender); | ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~/home/youliang/ros_ws/build/catkin_ws/src/rosconsole/src/rosconsole/impl/rosconsole_log4cxx.cpp: In function ‘void* ros::console::impl::getHandle(const string&amp;)’:/home/youliang/ros_ws/build/catkin_ws/src/rosconsole/src/rosconsole/impl/rosconsole_log4cxx.cpp:203:36: error: cannot convert ‘log4cxx::LoggerPtr’ &#123;aka ‘std::shared_ptr&lt;log4cxx::Logger&gt;’&#125; to ‘void*’ in return 203 | return log4cxx::Logger::getLogger(name); | ~~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~ | | 解决方法：将src目录下面的rosconsole更新成concise_output_roso分支 从GitHub - lucasw&#x2F;rosconsole https://github.com/lucasw/rosconsole 拉取rosconsole的源码，切到concise_output_roso分支，覆盖到~&#x2F;ros_catkin_ws&#x2F;src下。 123git clone -b concise_output_roso https://github.com/lucasw/rosconsole.git rm -rf src/rosconsolemv rosconsole src shared_mutex的问题 1234567891011121314151617181920212223242526272829make[2]: *** [CMakeFiles/tf.dir/build.make:118: CMakeFiles/tf.dir/src/transform_listener.cpp.o] Error 1In file included from /usr/include/log4cxx/log4cxx.h:45,from /usr/include/log4cxx/logstring.h:28,from /usr/include/log4cxx/level.h:22,from /opt/ros/noetic/include/ros/console.h:46,from /opt/ros/noetic/include/ros/ros.h:40,from /tmp/makepkg/ros-noetic-tf/src/geometry-1.13.2/tf/src/transform_broadcaster.cpp:34:/usr/include/log4cxx/boost-std-configuration.h:10:18: error: ‘shared_mutex’ in namespace ‘std’ does not name a type10 | typedef std::shared_mutex shared_mutex;| ^~~~~~~~~~~~/usr/include/log4cxx/boost-std-configuration.h:10:13: note: ‘std::shared_mutex’ is only available from C++17 onwards10 | typedef std::shared_mutex shared_mutex;| ^~~/usr/include/log4cxx/boost-std-configuration.h:12:30: error: ‘shared_lock’ in namespace ‘std’ does not name a template type12 | using shared_lock = std::shared_lock&lt;T&gt;;| ^~~~~~~~~~~/usr/include/log4cxx/boost-std-configuration.h:12:25: note: ‘std::shared_lock’ is only available from C++14 onwards12 | using shared_lock = std::shared_lock&lt;T&gt;;| ^~~In file included from /opt/ros/noetic/include/ros/console.h:46,from /opt/ros/noetic/include/ros/ros.h:40,from /tmp/makepkg/ros-noetic-tf/src/geometry-1.13.2/tf/src/transform_broadcaster.cpp:34:/usr/include/log4cxx/level.h:283:29: error: ‘mutex’ in namespace ‘std’ does not name a type283 | static std::mutex initMutex;| ^~~~~/usr/include/log4cxx/level.h:25:1: note: ‘std::mutex’ is defined in header ‘&lt;mutex&gt;’; did you forget to ‘#include &lt;mutex&gt;’?24 | #include &lt;log4cxx/helpers/object.h&gt;+++ |+#include &lt;mutex&gt;25 | 解决方法：修改&#x2F;usr&#x2F;include&#x2F;log4cxx&#x2F;boost-std-configuration.h中的 12#define STD_SHARED_MUTEX_FOUND 1#define Boost_SHARED_MUTEX_FOUND 0 为 12#define STD_SHARED_MUTEX_FOUND 0#define Boost_SHARED_MUTEX_FOUND 1 std_msgs问题 编译此包易出现找不到genmsg模块的报错，实际上我没有找到真正的原因 如果出现，请尝试商储缓存重新编译，获将一开始的流程重新来一遍 cv_brige问题 容易出现boost的版本冲突问题，原因在于我装了conda，conda里的cmake包带了boost是1.82的，和ros的1.74冲突了 解决方法 删除conda里面包含boost的包即可，注意刷新一下conda环境 source环境变量就可以用了1source ~/ros_catkin_ws/install_isolated/setup.bash 可以输入roscore启动master节点测试是否成功（没报红应该就没问题了） 本文就此结束，有需要可以联系邮箱：&#50;&#x30;&#56;&#52;&#x38;&#x39;&#x36;&#51;&#48;&#49;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;微信：wxcf9687","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://blog.gavinccc.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.gavinccc.com/tags/ubuntu/"},{"name":"ros","slug":"ros","permalink":"http://blog.gavinccc.com/tags/ros/"}]},{"title":"VScode配置STM32环境","slug":"VScode_create_stm32","date":"2024-07-04T19:00:23.000Z","updated":"2024-07-04T20:46:27.602Z","comments":true,"path":"2024/07/05/VScode_create_stm32/","permalink":"http://blog.gavinccc.com/2024/07/05/VScode_create_stm32/","excerpt":"使用Embedded IDE在vscode上部署keil arm环境，一举解决keil开发难受的问题vscode，爽！","text":"使用Embedded IDE在vscode上部署keil arm环境，一举解决keil开发难受的问题vscode，爽！ 基于Embedded IDE在vscode上配置STM32环境 前面配置了c51，当然少不了stm32嘿嘿 话不多说直接开干 还是使用EIDE与vscode，这里不过多赘述 打开EIDE安装扩展工具包分别是cppcheck、GNU Arm Embedded Toolchain、OpenOCD 安装cortex-debug vscode插件 设置编译环境 第一步：打开EIDE扩展设置 在vscode的扩展里头找到EIDE右键打开EIDE的扩展设置 第二步：在打开的设置中找到ARMCC5与ARMCC6两个框 第三步：将keil的ARM目录下的两个编译器路径填入 打开keil的安装目录（qrm架构的），打开下面的ARM目录，可以看到前面两个文件夹分别是ARMCC与ARMCLANG 将它们的分别路径复制（右键有复制路径的选项），粘贴到刚刚打开的两个框中,最后就像这样 设置工具链（这一步可能已经不需要了）按照图片打开工具链选择 选择kel目录下的TOOLS.INI 结束 新建或导入项目（导入可以导入keil项目）打开项目之后有这些选项，我们导入芯片支持包 第一个选项是联网下载，我们有离线包，选第二个选项随后选择我们当时安装的pack包就好了 构建配置选择默认，烧录配置按照我的来就好 别问为什么不选stlink，因为配置麻烦，而openocd支持stlink，其他默认就好了现在我们可以编译试试了 点击这两个都可以编译 当你看到下面一堆绿色…… 恭喜！！！编译成功，配置完成 让我们一鼓作气试试烧录 点击旁边这个看起来像下载的按钮，烧录！ 当你看到你的stlink开始闪烁，并且出现以下的界面 再次恭喜！！！烧录成功！！！ 一些小tips 不要使用中文文件名，会报错 有许多功能与界面对应着keil，如： 添加包含的文件夹 EIDEkeil 构建器选项 EIDEkeil","categories":[],"tags":[{"name":"VScode","slug":"VScode","permalink":"http://blog.gavinccc.com/tags/VScode/"},{"name":"Embedded IDE","slug":"Embedded-IDE","permalink":"http://blog.gavinccc.com/tags/Embedded-IDE/"}]},{"title":"Motrix操作手册","slug":"Motrix_readme","date":"2024-02-21T17:03:45.000Z","updated":"2024-02-26T08:38:12.945Z","comments":true,"path":"2024/02/22/Motrix_readme/","permalink":"http://blog.gavinccc.com/2024/02/22/Motrix_readme/","excerpt":"","text":"Motrix具有以下特点和功能： 多协议支持：Motrix支持多种下载协议，包括HTTP、FTP、BT（BitTorrent）、磁力链等，可以满足不同下载需求。 多任务管理：Motrix支持同时管理多个下载任务，可以方便地添加、暂停、恢复和删除下载任务，并提供详细的任务信息和进度展示。 下载加速：Motrix支持多线程下载和断点续传，可以加快下载速度并节省带宽。 浏览器插件支持：Motrix提供了浏览器插件，可以方便地将下载链接发送到Motrix进行下载操作。 任务调度和限速：Motrix支持任务调度功能，可以设置下载任务的优先级和顺序。此外，还可以设置下载速度限制，以免占用过多的网络资源。 高级功能：Motrix还提供了一些高级功能，如自动提取下载链接、自动分类文件、自动关机等。 使用说明下载与安装： 直接在网协分享网站share.gdmuna.com上直接下载 下载好motrix之后使用motrix下载其他网协分享网站的软件会十分高效 运行安装程序，按照提示完成Motrix的安装过程。 添加下载任务： 打开Motrix应用程序。 点击界面左上角的”+”按钮，或者使用快捷键Ctrl&#x2F;Command + N，弹出添加任务对话框。 在对话框中，输入要下载的文件的URL或磁力链接，并选择下载保存的路径，（我们在浏览器下载文件的时候在右上方会有下载进程我们右键这个进程会有一个【复制下载链接】选项。） 点击”提交”按钮，开始下载任务。 管理下载任务： 在Motrix的主界面，你可以看到当前正在下载的任务列表。 鼠标左键单击任务可以展开任务详情，包括下载进度、下载速度、剩余时间等信息。 鼠标右键单击任务，可以执行暂停、恢复、删除等操作。 设置任务优先级和顺序： 在任务列表中，你可以通过拖拽任务来调整任务的顺序。 右键单击任务，在上下文菜单中选择”设置优先级”，可以设置任务的优先级。 浏览器插件支持： Motrix提供了浏览器插件，可以方便地将下载链接发送到Motrix进行下载操作。 在Motrix的官方网站或浏览器的应用商店中搜索并安装Motrix的浏览器插件。 安装完成后，在浏览器中点击下载链接时，会弹出Motrix的下载对话框，选择下载任务即可。 其他高级功能： Motrix还提供了一些高级功能，如自动提取下载链接、自动分类文件、自动关机等。 你可以在Motrix的设置界面中，根据个人需求进行相应的配置。 网协分享盘大文件下载1.来到网协分享网站复制链接 share.gdmuna.com，来到网协分享网站复制大文件链接 2.打开Motrix粘贴链接 点加号 在框框里粘贴链接 点提交即可 3.让我们对比一下 这是浏览器下载速度 这是使用motrix的下载速度 接近20倍的速度！！！ 百度网盘链接 天下苦度盘久矣！！！ 1.修改motrix的ua 点击菜单栏的列表按钮，然后点击进阶设置，在安全性部分点击du 2.解析百度网盘下载链接 使用这个网站https://mf.xn--vzyr4p.top/解析百度网盘直链 3.根据下面图片提示完成 进入网站输入百度网盘链接 选择文件下载 点击发送到Motrix 注意更换prc地址 自动推送到motrix下载 可以看到右下角motrix已经下载完毕","categories":[],"tags":[]},{"title":"m3u8与mp4的互相转化","slug":"m3u82mp4","date":"2024-02-21T17:02:22.000Z","updated":"2024-02-26T08:38:12.946Z","comments":true,"path":"2024/02/22/m3u82mp4/","permalink":"http://blog.gavinccc.com/2024/02/22/m3u82mp4/","excerpt":"","text":"什么是m3u8？:::info正常来说，我们的视频格式都是mp4，但是mp4并不适合网络传播，在线播放视频将会十分困难，m3u8的出现改变了这一切，M3U8 是一种常用的视频流媒体播放列表格式，它使用分片（Chunk）的方式将视频内容切分成多个小片段，以便在网络上进行传输和播放。下面是关于 M3U8 分片原理的简要讲解：::: 原始视频切片：首先，将原始视频文件切分成短小的视频片段。这些片段通常是几秒钟到几十秒钟的长度，并且以.ts（Transport Stream）为扩展名。切片的目的是为了提供更好的网络传输和流媒体播放体验。 生成 M3U8 播放列表：在切片完成后，生成一个 M3U8 播放列表文件。这个文件是一个文本文件，其中包含了视频片段的信息和顺序。M3U8 播放列表使用标准的文本格式，可以在任何文本编辑器中打开和查看。 分片的索引和时长：M3U8 播放列表中的每个片段都有一个唯一的 URL，用于指定该片段的位置和访问方式。此外，每个片段还包含了其时长信息，以便播放器可以准确地控制和显示视频的进度。 自适应码率：M3U8 还支持自适应码率（Adaptive Bitrate）功能。在自适应码率中，同一段视频会根据用户的网络带宽和设备性能，提供多个不同分辨率和比特率的版本。播放器可以根据当前的网络状况，选择适合的视频分辨率和比特率进行播放，以提供最佳的观看体验。 动态加载和播放：当用户开始播放 M3U8 文件时，播放器会根据 M3U8 播放列表中的信息，动态加载视频片段并按照顺序播放。播放器会根据每个片段的时长和码率，自动控制缓冲和下载速度，以确保连续的播放和流畅的体验。:::info一言以蔽之，m3u8是一种视频格式，它的出现使网络视频传播变得非常流畅::: 为什么mp4格式不适合网络传播？ 文件大小：MP4 文件通常相对较大，特别是对于高分辨率和高比特率的视频来说。这导 致在网络传输过程中需要更长的时间和更大的带宽来下载和播放。对于用户来说，下载大 型的 MP4 文件可能需要等待时间较长，尤其是在网络连接较慢的情况下。 缓冲和加载时间：由于 MP4 文件的大小，播放器在开始播放之前需要先下载一部分视频内容进行缓冲。这意味着用户可能需要等待一段时间才能开始观看视频，特别是对于较长的视频来说。在网络不稳定或带宽有限的情况下，缓冲和加载时间可能会更长。 不适应网络波动：MP4 文件通常需要完全下载后才能开始播放。这意味着如果网络连接中断或不稳定，用户可能无法顺利播放视频。在网络传输过程中，如果发生网络波动或中断，用户可能需要重新下载整个视频文件或等待缓冲重新开始。:::info总的来说，MP4 文件适合本地播放和存储，而对于网络传播和流媒体播放，使用专门的流媒体格式如 M3U8 更为合适，可以提供更好的用户体验和适应性。::: m3u8与mp4可以互相转化吗？可以!!但是需要通过一些工具，如FFmpeg等，接下来将会有一个详细的教程告诉大家怎么将m3u8转化成mp4. 以腾讯课堂视频下载为例 1.获取工具包 share.gdmuna.com 2.获取腾讯课堂视频 第一步：登录到下载器 在浏览器登录自己的腾讯课堂账号，随后右键点击检查打开控制台，输入document.cookie,复制结果 使用记事本打开这个文件 在这个地方把刚刚复制的cookie粘贴进去 打开这个软件 输入login查看登录状态 获取腾讯课堂的cid，复制这串数字 回到控制台，输入tree -c 选择要下载的视频，输入d 编号 下载，一般来说，编号1就是下载全部 下载好之后存放在这个文件夹中，是m3u8格式 3.转化成mp4 点击上面的download文件夹，直到打开m3u8文件 打开并且右键这个文件复制文件路径（必须要这个文件） 打开这个软件 把刚刚复制的路径粘贴到这里面，然后点击go 然后就会开始下载 下载完之后，会有一个文件夹 打开之后就有mp4文件了！！！ 免责声明本文仅供学习和研究目的，提供有关特定主题的信息和指导。请注意以下重点强调的免责声明，以确保您理解并遵守本文的使用目的。 仅供学习研究：本文的目的是为读者提供学习和研究特定主题的参考资料。它不应被视为专业建议、指导或解决方案的替代品。读者在使用本文中的任何内容时，应自行评估其适用性，并在必要时寻求专业意见。 个人责任：本文中的任何建议、指导或观点仅代表作者个人的意见和观点，并不代表本平台或任何其他组织或个人的立场。读者在根据本文的内容进行任何行动或决策时，应自行承担个人责任，并对其结果负责。 第三方内容和链接：本文可能包含指向第三方网站、资源或内容的链接。这些链接仅为方便读者提供，并不构成对这些第三方内容的认可、推荐或担保。我们对这些第三方内容的准确性、安全性和合法性不承担任何责任。 免责声明的适用范围：本免责声明适用于本文的所有内容，包括文字、图像、链接和其他形式的信息。本文的阅读和使用即视为您已接受本免责声明，并同意自行承担使用本文内容所产生的风险和责任。","categories":[],"tags":[]},{"title":"基于VUE+Element+Vite的前端流程设计","slug":"VUE","date":"2024-02-01T01:52:35.000Z","updated":"2024-02-26T08:38:12.946Z","comments":true,"path":"2024/02/01/VUE/","permalink":"http://blog.gavinccc.com/2024/02/01/VUE/","excerpt":"本文为本人于2024年1月15日在网协开的直播课程的详细描述《Vue+Vite+Element前端整体流程设计》提供文档版本以供方便学习","text":"本文为本人于2024年1月15日在网协开的直播课程的详细描述《Vue+Vite+Element前端整体流程设计》提供文档版本以供方便学习 配合视频观看更佳！ 前期准备在开始前端之旅之前，我们不得不准备好一些必要的东西 Node.jsNode.js是前端开发环境，它的出现造成了前端大爆发，也造就了React和Vue的辉煌，它是目前前端必不可少的npm前端的爆发使js开发者越来越多，开源贡献者也越来越多，于是凝结出了世界上最大的软件包仓库，它是前端开发者接轨世界必不可少的nvm一个Node.js的版本管理工具 如果你并没有准备好这些必要的工具，请前往以下站点阅读配置 Node.js开发环境部署https://share.gdmuna.com/soft_installer/nvm 由于npm镜像源在国外，国内速度受限,可以配置国内镜像源加速，参考以下文章配置 设置npm镜像源的方法https://blog.seeleclover.com/2022/12/28/npm-settings/ 还可以换成yarn包管理工具，区别在于yarn更快！ 1npm install --global yarn 使用cmd运行即可 开始vite工程在开始之前，请再次确认是否已准备完成 打开cmd运行以下命令，请在合适的文件夹打开cmd（右键打开终端即可） yarnnpm1yarn create vite my-vue-app --template vue1npm create vite@latest 这里面的my-vue-app换成自己项目名字记得选择JavaScript note bug red 如果出现bug报错请尝试更换网络或者更换终端,或者使用npm 根据运行以下命令1.移至项目目录 1cd my-vue-app 这里的my-vue-app是自己的项目名 2.下载依赖（就是在npm源中下载需要的库） yarnnpm1yarn1npm i 3.启动项目 yarnnpm1yarn dev1npm run dev 运行成功看到以下状态 红框框起来的网址端口就是vite工程的端口 点开这个网址就可以看到工程展示界面 至此，启动工程就结束了 VSCode编写vite+vue工程使用vscode打开刚刚创建好的工程目录 打开之后第一件事将npm脚本勾选上，这样就可以使用图形化界面运行脚本（而非命令） 我们依次来看工程目录的作用 .vscode:存放vscode的配置文件 node_modules:存放安装好的依赖包 piblic:存放音频图片的文件，该目录下的文件在打包时不会更改路径，在引用该目录下的文件时仅需（.&#x2F;文件名） src:存放代码文件，一般来说，我们只会在src目录下进行活动 src.assets:存放音频图片的文件,引用该目录文件时需正常填写相对路径 src.components: 存放vue工程的组件代码 src.pages:存放vue工程的页面代码（原本并没有这个目录，是我自己创的） src.App.vue:vue的入口文件 src.style.css:整个工程的css src.main.js:全局js index.html:整个工程的html文件，挂载着App.vue package.json:工程的配置文件清单，npm i命令就是在这个文件中寻找所需依赖 最后我们来看一下vue是怎么写的 123456789101112131415161718192021&lt;template&gt; &lt;h1&gt;这里存放html代码:&#123;&#123; msg &#125;&#125;&lt;/h1&gt;&lt;/template&gt;&lt;script&gt;// 这里存放js代码export default &#123; data() &#123; return &#123; msg: &#x27;Welcome to Your Vue.js App&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;/* 这里存放css代码 */h1&#123; color: red;&#125;&lt;/style&gt; 除了js部分编写代码可能有所不同其余皆相同，值得注意的是css标签加上的scoped是为了避免选择器冲突问题 页面、路由和组件页面 在开始之前，我们要明白，开发一个app,无论是web、桌面或者小程序，第一个开发的是什么界面呢？ 不会给大家卖关子，首先要开发的一定是作用域范围最广的界面 用户进app最先的肯定是登录界面，然鹅那是用户登录逻辑而不是界面逻辑 比如一个手机app小程序，就像微信，作用域范围最广的就是微信底下的导航栏，如下 这个底下的导航栏，首页、分类、推荐、我的就是作用域范围最广的界面body的内容可以更换，但是底下的永远不变 以此为准，我们写一个界面出来，首先创建pages目录然后新建trunk.vue文件，trunk的意思是主干的意思，最广作用域范围的界面就是整个app的主干 好的我直接把我trunk.vue的代码放出来 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;h1&gt;body&lt;/h1&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot;&gt; &lt;div class=&quot;footmenu&quot;&gt; &lt;span &gt;首页&lt;/span&gt; &lt;span &gt;分类&lt;/span&gt; &lt;span &gt;推荐&lt;/span&gt; &lt;span &gt;我的&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style scoped&gt;.main &#123; height: 93vh; width: 100vw;&#125;.footmenu &#123; box-shadow: 0px -1px 1px #dcdfe6; height: 7vh; width: 100vw; background-color: #fff; display: flex; justify-content: space-around; align-items: center;&#125;span &#123; width: 25%; height: 100%; line-height: 400%;&#125;&lt;/style&gt; 我们还需要在App.vue导入trunk.vue 123456789101112131415161718192021222324&lt;script&gt;import trunk from &#x27;./pages/trunk.vue&#x27;;export default &#123; components: &#123; trunk, &#125;,&#125;;&lt;/script&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;trunk /&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50;&#125;&lt;/style&gt; 这里的trunk标签就是trunk.vue的页面了 然而只是徒有其表而已，可以在浏览器预览一下 body部分有点不一样，没关系，下面一样就好了 问题在哪，就在于body部分是需要变化的，当我点击下面的导航栏，body的部分应该发生变化，显然，这个代码并不能实现我的需求 为解决这个问题，我们使用路由来解决，vue-router 路由大家可以去源站看router的教程 vue-routerhttps://router.vuejs.org/zh/ 配置router1.引入router在项目目录打开cmd输入命令导入 yarnnpm1yarn add vue-router@41npm install vue-router@4 直接打开vscode的cmd输入即可 2.编写router.js文件并全局引入router.js 在src目录新建应该router目录并在该目录创建router.js文件在里面写入以下代码 12345678910111213141516171819202122import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;&#x27;, redirect: &#x27;/home&#x27;, &#125;, &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../pages/home.vue&#x27;), meta: &#123; home: true, &#125;, &#125;, ],&#125;);export default router; 有人问为什么要这么写，这里不做过多阐述，需要了解的请点上面的链接进router官网学习 点开main.js，添加以下代码 12import router from &#x27;./router/router.js&#x27;;createApp(App).use(router).mount(&#x27;#app&#x27;); 其中createApp(App).mount(‘#app’);原本就有了，只需要加入.use(router)即可 这样子，页面首先就会跳到home界面了 我们现在要实现4个界面，分别是首页，分类，推荐，我的我们分别在pages目录创建home.vue,classify.vue,about.vue,user.vue并在里面编写内容 然后在router.js加入这些页面的路由 以下是完整的router.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;;const router = createRouter(&#123; history: createWebHistory(), routes: [ &#123; path: &#x27;/&#x27;, name: &#x27;&#x27;, redirect: &#x27;/home&#x27;, &#125;, &#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../pages/home.vue&#x27;), meta: &#123; home: true, &#125;, &#125;, &#123; path: &#x27;/user&#x27;, name: &#x27;user&#x27;, component: () =&gt; import(&#x27;../pages/user.vue&#x27;), meta: &#123; user: true, &#125;, &#125;, &#123; path: &#x27;/classify&#x27;, name: &#x27;classify&#x27;, component: () =&gt; import(&#x27;../pages/classify.vue&#x27;), meta: &#123; classify: true, &#125;, &#125;, &#123; path: &#x27;/about&#x27;, name: &#x27;about&#x27;, component: () =&gt; import(&#x27;../pages/about.vue&#x27;), meta: &#123; about: true, &#125;, &#125;, ],&#125;);export default router; 3.在trunk中加入跳转函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot; v-show=&quot;!$route.meta.childrenPage&quot;&gt; &lt;div class=&quot;footmenu&quot;&gt; &lt;span @click=&quot;goToHome&quot;&gt;首页&lt;/span&gt; &lt;span @click=&quot;goToClassify&quot;&gt;分类&lt;/span&gt; &lt;span @click=&quot;goToAbout&quot;&gt;推荐&lt;/span&gt; &lt;span @click=&quot;goToUser&quot;&gt;我的&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Icon from &#x27;../components/Icon.vue&#x27;;export default &#123; name: &#x27;Trunk&#x27;, components: &#123; Icon, &#125;, data() &#123; return &#123; isActive: 1, &#125;; &#125;, methods: &#123; goToUser() &#123; this.$router.push(&#x27;/user&#x27;); &#125;, goToHome() &#123; this.$router.push(&#x27;/home&#x27;); &#125;, goToClassify() &#123; this.$router.push(&#x27;/classify&#x27;); &#125;, goToAbout() &#123; this.$router.push(&#x27;/about&#x27;); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;.main &#123; height: 93vh; width: 100vw;&#125;.footmenu &#123; box-shadow: 0px -1px 1px #dcdfe6; height: 7vh; width: 100vw; background-color: #fff; display: flex; justify-content: space-around; align-items: center;&#125;span &#123; width: 25%; height: 100%; line-height: 400%;&#125;&lt;/style&gt; 这里的就是可更换区域，点击我的就会将user.vue的内容放在这里面来，其他的亦是如此 预览一下 Your browser does not support the video tag. oky已经完成了！ 组件这里不做过多赘述 写在components目录下的文件即为组件需要注意的是 组件需要具有复用性高，实用性强的特点，不能说我一个颜色都弄一个组件吧 例子：我封装了一个头部导航栏可以循环复用我可以在其他页面使用，比如在首页和分类以及推荐都加上这个组件 ElementsPlus的引入与使用前端的大力发展也使的各种ui组件库层出不穷，什么是组件库？ 我们自己会编写组件，会发现有些组件的复用性非常非常高，比如button、tag等，于是许多厂商为了统一开发风格，将大部分常用的组件做成组件库，方便调用，大部分也开源了 其中，Elementui凭借它强大的稳定性，成为许多新人入门组件库的第一选择 大家可以去Element的官网查看文档 ElementPlus官方网站https://element-plus.org/zh-CN/ Elements的引入（全局引入）在项目终端输入命令以导入Element yarnnpm1yarn add element-plus1npm install element-plus --save 在main.js文件中加入以下代码 1234import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;app.use(ElementPlus) 现在我们的main.js如下 12345678import &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router/router.js&#x27;createApp(App).use(router).use(ElementPlus).mount(&#x27;#app&#x27;) 现在，我们就可以在任意一个文件中使用Element了 Element的使用我们需要一边浏览Element的组件文档一边使用Element组件 ElementPlus组件文档https://element-plus.org/zh-CN/component/button.html 比如我使用一个element的button组件 我在官方文档查看代码，直接在需要的地方直接写进去 让我们看看预览效果 成功！ 其他组件，按需求使用即可 iconfont的引入与使用前端的工程避免不了使用到各种各样的图标，因此网上的图标库也是非常丰富的，比较著名的有fontawsome，其中iconfont是阿里巴巴图标库，是国内最大的图标库 本工程图标库使用iconfont作为图标库 iconfont官网https://www.iconfont.cn/ 首先在官网登录后点开我的项目 新建一个项目 名字随便起，尽量英文 随后在右上角的搜索栏搜索需要的图标，英文搜索最好，在这里我们搜索一下user 可以看到有非常非常多的图标 选择好之后将鼠标悬浮点击购物车图标 选择好几款（可以再次搜索多选择几个）点击右上角购物车图标，随后点击添加到项目 选择刚刚创建好的项目 根据图片的步骤生成代码，记得打开在线链接 复制这个代码即可 在components目录新建icon.vue 并输入以下代码 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;i class=&quot;iconfont&quot; :class=&quot;[iconclass, extraclass]&quot;&gt;&lt;/i&gt; &lt;/template&gt; &lt;script&gt; var map = &#123; user: &#x27;icon-caidan07&#x27;, user1：&#x27;icon-custom-user&#x27; &#125;; export default &#123; props: &#123; type: &#123; type: String, required: true, &#125;, extraclass: &#123; type: String, default: &#x27;&#x27;, &#125;, &#125;, computed: &#123; iconclass() &#123; return map[this.type]; &#125;, &#125;, &#125;; &lt;/script&gt; &lt;style scoped&gt; &#123;/* 输入自己的项目代码 */&#125; @import &#x27;//at.alicdn.com/t/c/font_4186478_3epgt7s339h.css&#x27;; &lt;/style&gt; 这里的map对象就是一个映射，将右边的字符串赋值给左边的变量，右边的字符串里面需要填写iconfont的代码 左边随意取名，这样，在其他页面使用时就填左边自己取名的变量即可 这样就打包好了一个icon组件，使用也非常简单 比如就在刚刚的about界面里面使用 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class=&quot;head&quot;&gt; &lt;Headerlist/&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;el-button&gt;你好&lt;/el-button&gt; &lt;Icon type=&quot;user1&quot; extraclass=&quot;icon&quot;/&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;import Headerlist from &#x27;../components/header.vue&#x27;import Icon from &#x27;../components/Icon.vue&#x27;;export default &#123; name: &#x27;home&#x27;, components: &#123; Headerlist,Icon &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.icon&#123; font-size: 30px;&#125;&lt;/style&gt; 这里Icon的type就是刚刚在icon组件定义的变量，对应着iconfont的图标还可以使用extraclass定义类名在父组件修改样式 预览效果 这样我们的icon就这样完结了 模板语法的使用根据前面的章节，很多人会觉得，vue似乎有许多功能都木有使用出来，很正常 毕竟我在上课开始的时候就说过，我并不会在直播课上教vue的语法等vue知识，我一直说，这些知识时需要自己去研究的，b站上面有许多vue的学习视频，需要自己去学习 但实际上，我也说过，我要教会大家基本能够开发前端小工程，然而一些基本的vue知识如果没有的话，的确时不可行的 以下是我学习vue时的学习视频，我的课程也是依此来构建的，大家学习vue时，按照自己的需求来挑选视频，适合自己的才是最好的 vue开发宝典https://www.bilibili.com/video/BV1wh41197Ja/?spm_id_from=333.337.search-card.all.click&vd_source=eb9228ddb7ee3296ae4533129fea06a5 好的，正式开始我们的vue的模板语法教程 事实上我只教一个语法 data值在vue中的调用 正常的一个vue文件是这样的 123456789101112&lt;template&gt; &lt;h1 id=&quot;name&quot;&gt;李白&lt;/h1&gt; &lt;h2 id=&quot;number&quot;&gt;1110909098&lt;/h2&gt; &lt;/template&gt;&lt;script&gt;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 很明显，这个h1和h2分别是姓名和学号，我们当然可以写死在html部分，然而在实际开发中，这里的姓名和学号必然是用户自己的，需要他自己写进去传到后端，然后前端调用后端再显示，因此我们不可能将其写死在html部分，调用后端是使用JavaScript来调用的，调用回来的一般是对象或者变量，这里我们不阐述调用过程，只对JavaScript对象在html标签上的显示进行阐述 在常规的JavaScript中我们是怎么做的呢？ 123456789101112131415161718192021222324&lt;template&gt; &lt;h1 id=&quot;name&quot;&gt;李白&lt;/h1&gt; &lt;h2 id=&quot;number&quot;&gt;1110909098&lt;/h2&gt; &lt;/template&gt;&lt;script&gt;// 创建一个 JavaScript 对象let person = &#123; name: &quot;李白&quot;, number: 1110909098,&#125;;// 获取 h1 标签元素let h1Element = document.getElementById(&quot;name&quot;);let h2Element = document.getElementById(&quot;number&quot;);// 将对象的 name 值设置为 h1 标签的文本内容h1Element.textContent = person.name;h2Element.textContent = person.number;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 看起来似乎也不难，然而这样子可读性的降低，如果能够直接在html里面调用变量或者对象就好了 很显然，铺垫这么久，要的就是告诉大家vue实现了这个功能 以下就是vue的演示 12345678910111213141516171819&lt;template&gt; &lt;h1 id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h2 id=&quot;number&quot;&gt;&#123;&#123; number &#125;&#125;&lt;/h2&gt; &lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: &#x27;李白&#x27;, number: 1110909098 &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 很明显，无论是可读性还是实用性，vue都遥遥领先 还有！还有两处地方调用变量时会使用vue特性，分别是html标签头和script标签内部 在这里我直接一次性展示完了 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h1 id=&quot;name&quot;&gt;&#123;&#123; name &#125;&#125;&lt;/h1&gt; &lt;h2 id=&quot;number&quot; :style=&quot;&#123;color:color&#125;&quot;&gt;&#123;&#123; number &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeColor&quot;&gt;改变颜色&lt;/button&gt; &lt;intput :type=&quot;type&quot; v-model=&quot;name&quot;/&gt; &lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; name: &#x27;李白&#x27;, number: 1110909098, color: &#x27;red&#x27;, type: &#x27;text&#x27; &#125; &#125;, methods: &#123; changeColor() &#123; this.color = &#x27;blue&#x27; &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 模板语法篇展示完毕 v-for循环现在你是程序猿，我给你一个需求，这个需求是，我要你做一个卡片，里面是一个照片，卡片的数量取决于客户上传的照片数量，你会怎么做？ 由于数量不是固定的，写死的做法一定不行，如下面这个，一定会被领导骂死 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Dynamic Elements&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt; &lt;div id=&quot;container&quot;&gt;&lt;img/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 聪明的你一定想得到使用js完成动态创建即可，如下面的代码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Dynamic Elements&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot;&gt;&lt;/div&gt; &lt;script&gt; const container = document.getElementById(&#x27;container&#x27;); const numElements = 10; // 这里可以根据需要设置元素的数量 for (let i = 0; i &lt; numElements; i++) &#123; const div = document.createElement(&#x27;div&#x27;); const img = document.createElement(&#x27;img&#x27;); div.appendChild(img); container.appendChild(div); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 很不错，可以使用简单的js循环完成构建，不过呢，在vue中，我们不需要再在js中写这些代码，可以直接在html中使用for循环 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;div id=&quot;container&quot; v-for=&quot;item in datalist&quot; :key=&quot;item.id&quot;&gt; &lt;img :src=&quot;item.src&quot;/&gt; &lt;h2&gt;&#123;&#123; item.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; datalist:[ &#123;id:1,src:&#x27;../assets/img/1.jpg&#x27;,name:&#x27;李一&#x27;&#125;, &#123;id:2,src:&#x27;../assets/img/2.jpg&#x27;,name:&#x27;李二&#x27;&#125;, &#123;id:3,src:&#x27;../assets/img/3.jpg&#x27;,name:&#x27;李三&#x27;&#125;, &#123;id:4,src:&#x27;../assets/img/4.jpg&#x27;,name:&#x27;李四&#x27;&#125;, &#123;id:5,src:&#x27;../assets/img/5.jpg&#x27;,name:&#x27;李五&#x27;&#125;, &#123;id:6,src:&#x27;../assets/img/6.jpg&#x27;,name:&#x27;李六&#x27;&#125;, &#123;id:7,src:&#x27;../assets/img/7.jpg&#x27;,name:&#x27;李七&#x27;&#125;, &#123;id:8,src:&#x27;../assets/img/8.jpg&#x27;,name:&#x27;李八&#x27;&#125;, &#123;id:9,src:&#x27;../assets/img/9.jpg&#x27;,name:&#x27;李九&#x27;&#125;, &#123;id:10,src:&#x27;../assets/img/10.jpg&#x27;,name:&#x27;李十&#x27;&#125;, &#123;id:11,src:&#x27;../assets/img/11.jpg&#x27;,name:&#x27;李十一&#x27;&#125;, &#123;id:12,src:&#x27;../assets/img/12.jpg&#x27;,name:&#x27;李十二&#x27;&#125;, &#123;id:13,src:&#x27;../assets/img/13.jpg&#x27;,name:&#x27;李十三&#x27;&#125;, &#123;id:14,src:&#x27;../assets/img/14.jpg&#x27;,name:&#x27;李十四&#x27;&#125;, &#123;id:15,src:&#x27;../assets/img/15.jpg&#x27;,name:&#x27;李十五&#x27;&#125;, ] &#125; &#125;,&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 在这里面，我们使用循环绑定了datalist数组，将其图片路径绑定在img标签的src上，再将数组中的name绑定再h1标签值里，这样，客户上传多少图片和名字，我们都可以将图片路径传至datalist数组中，这样就实现了动态的循环元素 这里的item in datalist是将datalist数组绑定于item，这样在循环的元素中使用datalist的值就用item.值即可（如上面的代码所示） 这里面的key是为了以下因素(点击查看) 性能优化：key 属性帮助 Vue 识别每个列表中的元素，从而在更新 DOM 时更高效地定位和更新元素，减少不必要的 DOM 操作，提高性能。唯一性：key 属性确保每个循环生成的元素具有唯一的标识符，避免出现相同 key 值导致的渲染问题。追踪变化：通过 key 属性，Vue 能够准确地追踪每个元素的变化，确保在列表数据发生变化时正确更新 DOM。复用元素：key 属性还有助于 Vue 识别元素之间的关系，以便在可能的情况下尽可能地复用已存在的 DOM 元素，而不是销毁和重新创建。 组件传值很多时候，我们会将一些复用性高的元素组件化，比如我们将上面v-for循环部分的代码组件化我们就会发现一个问题（以下称之为card组件） 如果我在home界面使用这个card组件（可能是为了统一卡片风格）home页面可能是为了摆放热门照片 然后我们又在user页面使用这个card组件，user界面一般是是摆放个人照片 很显然，如果在这个car的组件中直接将图片路径等信息直接传入，就会出现在home组件和user组件都是一样的图片 我们需要肯定不是这样，我们需要的是每一个页面都是由每个页面自己决定的，这个时候我们就需要在父组件中将值传给子组件了 那么，怎么传值呢？答案就是使用vue的props属性，让我们来看看最简单的使用 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;ChildComponent :message=&quot;parentMessage&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import ChildComponent from &#x27;./ChildComponent.vue&#x27;;export default &#123; components: &#123; ChildComponent &#125;, data() &#123; return &#123; parentMessage: &#x27;Hello from Parent!&#x27; &#125;; &#125;&#125;&lt;/script&gt;// ChildComponent.vue&lt;template&gt; &lt;div&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; message: String // 指定 message 的类型为字符串 &#125;&#125;&lt;/script&gt; 知道怎么使用了吧，让我们依此来完善我们的card组件 已知，我们card需要的是数组属性直接来吧 card.vuehome.vueuser.vue123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;div id=&quot;container&quot; v-for=&quot;item in datalist&quot; :key=&quot;item.id&quot;&gt; &lt;img :src=&quot;item.src&quot;/&gt; &lt;h2&gt;&#123;&#123; item.name &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; datalist: &#123; type: Array, default: () =&gt; [] &#125; &#125;&#125;&lt;/script&gt;&lt;style&gt;.container &#123; height: 100px; width: 100px; border: 1px solid #000; margin: 10px; display: inline-block; text-align: center; padding: 10px; box-sizing: border-box; img&#123; width: 80%; height: 80%; &#125;&#125;&lt;/style&gt;1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div class=&quot;head&quot;&gt; &lt;Headerlist/&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;!-- &lt;livecard :datalist=&quot;alist&quot; &gt;&lt;/livecard&gt; --&gt; &lt;card :datalist=&quot;blist&quot;&gt;&lt;/card&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;import livecard from &#x27;../components/livecard.vue&#x27;import Headerlist from &#x27;../components/header.vue&#x27;import exmaple from &#x27;../components/card.vue&#x27;export default &#123; name: &#x27;home&#x27;, components: &#123; Headerlist,livecard,card &#125;, data()&#123; return&#123; // alist:[ // &#123; // id:1, // imgurl:&#x27;https://element-plus.org/images/element-plus-logo.svg&#x27;, // title:&#x27;element-plus&#x27;, // tag:&#x27;vue3.0&#x27;, // space:&#x27;kuaile&#x27;, // yanse:&#x27;success&#x27; // &#125; // ], blist:[ &#123;id:1,src:&#x27;../assets/img/1.jpg&#x27;,name:&#x27;李一&#x27;&#125;, &#123;id:2,src:&#x27;../assets/img/2.jpg&#x27;,name:&#x27;李二&#x27;&#125;, &#123;id:3,src:&#x27;../assets/img/3.jpg&#x27;,name:&#x27;李三&#x27;&#125;, ] &#125; &#125;&#125;&lt;/script&gt;123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;span class=&quot;span&quot;&gt;&lt;el-button @click=&quot;gomessage&quot;&gt;我的信息&lt;/el-button&gt;&lt;/span&gt; &lt;card :datalist=&quot;clist&quot;&gt;&lt;/card&gt;&lt;/template&gt;&lt;script&gt;import exmaple from &#x27;../components/card.vue&#x27;export default &#123; components: &#123; card &#125;, name: &#x27;mymessage&#x27;, methods:&#123; gomessage()&#123; this.$router.push(&#x27;/user/mymessage&#x27;) &#125; &#125;, data()&#123; return&#123; clist:[ &#123;id:1,src:&#x27;../assets/img/6.jpg&#x27;,name:&#x27;李六&#x27;&#125;, &#123;id:2,src:&#x27;../assets/img/7.jpg&#x27;,name:&#x27;李七&#x27;&#125;, &#123;id:3,src:&#x27;../assets/img/8.jpg&#x27;,name:&#x27;李八&#x27;&#125;, &#123;id:4,src:&#x27;../assets/img/9.jpg&#x27;,name:&#x27;李九&#x27;&#125;, ] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.span&#123; border: 2px solid #000; color: #000;&#125;&lt;/style&gt; 让我们来看一下效果 home页面效果user页面效果 因为我并没有放真实的图片，大家将就着看 在icon篇也是使用了组件传值的原理 最后献上我的真实的livecard以供大家参考 livecard.vuehome.vuehome页面预览效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//记住是全局引入了element的&lt;template&gt; &lt;div class=&quot;body&quot;&gt; &lt;div class=&quot;main&quot; v-for=&quot;item in datalist&quot; :key=&quot;item.id&quot;&gt; &lt;div class=&quot;left&quot;&gt; &lt;div class=&quot;image&quot;&gt; &lt;img :src=&quot;item.imgurl&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; &lt;div class=&quot;text&quot;&gt; &lt;div&gt;&lt;h3&gt;&#123;&#123; item.title &#125;&#125;&lt;/h3&gt;&lt;/div&gt; &lt;div class=&quot;tagfather&quot;&gt;&lt;el-tag class=&quot;ml-2 tagnew&quot; :type=&quot;item.yanse&quot;&gt;&#123;&#123; item.tag &#125;&#125;&lt;/el-tag&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;space&quot;&gt; &lt;h4&gt;&#123;&#123; item.space &#125;&#125;&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;livecard&#x27;, props: &#123; datalist: &#123; type: Array, default: () =&gt; [] &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;.main&#123; width: 100vw; height: 100px; border: 1px solid #000;&#125;.left&#123; width: 30%; height: 100px; float: left; border: 1px solid #000;&#125;.right&#123; width: 70%; height: 100px; float: left;&#125;.image img&#123; width: 100px; height: 90px; object-fit: cover;&#125;.text&#123; width: 100%; height: 50px; position: relative;&#125;.text h3&#123; position: absolute; top: 15%; left: 5%; font-size: 20px;&#125;.space&#123; width: 100%; height: 50px; position: relative;&#125;.space h4&#123; position: absolute; top: 15%; left: 5%; font-size: 17px;&#125;.tagnew&#123; position: absolute; top: 15%; right: 5%; padding: 0 10px; border: none; cursor: pointer;&#125;&lt;/style&gt;12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;head&quot;&gt; &lt;Headerlist/&gt; &lt;/div&gt; &lt;div class=&quot;main&quot;&gt; &lt;livecard :datalist=&quot;alist&quot; &gt;&lt;/livecard&gt; &lt;/div&gt; &lt;/template&gt;&lt;script&gt;import livecard from &#x27;../components/livecard.vue&#x27;import Headerlist from &#x27;../components/header.vue&#x27;export default &#123; name: &#x27;home&#x27;, components: &#123; Headerlist,livecard &#125;, data()&#123; return&#123; alist:[ &#123; id:1, imgurl:&#x27;https://element-plus.org/images/element-plus-logo.svg&#x27;, title:&#x27;element-plus&#x27;, tag:&#x27;vue3.0&#x27;, space:&#x27;kuaile&#x27;, yanse:&#x27;success&#x27; &#125; ] &#125; &#125;&#125;&lt;/script&gt; 路由跳转的进阶使用meta的使用根据，我们上面的路由篇。为我们可以使用并创建简单的路由跳转，但是同时我们也会陷入一个难题，比如微信，下面的导航栏确实是作用域范围最广的组件，但是它却并不是全作用域，我们点开朋友圈，点开朋友的聊天界面，点开我们的设置界面，都会发现，下面的导航栏消失了，这很正常，非常符合我们的逻辑需求，然而对于前面的学习，似乎有点懵了，似乎下面的主导航栏已经成为必不可少或者说我们无法令其消失。 很显然，我的教程并不能让大家做到，好吧，我的问题 不过也不难，使用简单的v-if或v-show语句即可(什么？v-if和v-show你不知道是什么？百度哈) 以下是路由跳转的进阶使用和小技巧 让我们来看一下逻辑 首先界面是这样的 一个基础的”我的”界面，其中有”我的信息”按钮，点进去可以看到个人详细信息 很明显，当我点击这个按钮时，下方的导航栏应该消失，取而代之的是上方出现返回按钮，对于这个界面，作用域范围最广的组件就是上方的返回导航栏 那么得知这个概念，我们就要动手了，该怎么做？ 当点击”我的信息”按钮时，取消下方导航栏的显示，增加上方导航栏的显示，上方导航栏可以直接当作”我的信息”界面的组件之一 让我们关注到之前写路由文件router.js时写的一个属性meta 官网对它的解释时这样的 vue-router对meta的解释https://router.vuejs.org/zh/api/interfaces/RouteLocationNormalizedLoaded.html#Properties-meta 不知道大家有没有看懂，反正我没有，简而言之，就是router的一个属性，可以将其当作正常的对象的一个属性来使用，其次，由于router我们全局注册了，因此这个属性我们也可以全局使用 我们是这么写router的 12345678&#123; path: &#x27;/home&#x27;, name: &#x27;home&#x27;, component: () =&gt; import(&#x27;../pages/home.vue&#x27;), meta: &#123; home: true, &#125;,&#125; 值得注意的是,这个属性在这里是一个布尔值，它为true的条件是当前的路由为&#x2F;home，意思就是当前页面是什么路由，哪个的meta就为true 因此我们只要检测路由不是”首页”,”分类”，”推荐”，”我的”四个界面即可，我们可以给所有在其之下的页面的meta取名为同样的名字，如childrenPage(子页面)，随后我们检测childrenPage的meta值，当其为true时，将下方导航栏的显示取消，当其为flase时，将其显示 123456789101112131415161718192021222324&#123; path: &#x27;/user/myMassage&#x27;, name: &#x27;myMassage&#x27;, component: () =&gt; import(&#x27;../pages/userPages/myMassage.vue&#x27;), meta: &#123; childrenPage: true, &#125;,&#125;,&#123; path: &#x27;/user/historyMassage&#x27;, name: &#x27;historyMassage&#x27;, component: () =&gt; import(&#x27;../pages/userPages/historyMassage.vue&#x27;), meta: &#123; childrenPage: true, &#125;,&#125;,&#123; path: &#x27;/user/moneyMassage&#x27;, name: &#x27;moneyMassage&#x27;, component: () =&gt; import(&#x27;../pages/userPages/moneyMassage.vue&#x27;), meta: &#123; childrenPage: true, &#125;,&#125;, 如果是在原生js中，这一步可能又要费许多功夫，但是在vue里面的v-if和v-show非常轻松的帮我们解决了这一痛点 他们的共同点，当条件为假时，页面上不会显示该元素标签使用方法如下 12&lt;div v-if=&quot;a == 1&quot;&gt;HELLO&lt;/div&gt;&lt;div v-show=&quot;a == 1&quot;&gt;HELLO&lt;/div&gt; 当变量a不等于1时，该div不会被显示出来 v-if和v-show的不同： v-show如果不满足条件相当于display: none，页面渲染完成后，你其实是可以用js去操纵隐藏起来的DOM的 而v-if如果不满足条件，在页面渲染完成后，对应的DOM是直接不会在HTML代码中出现的 当你有一部分隐藏的页面组件想在页面渲染完成后用原生js去操纵，或者允许爬虫之类的东西来抓取隐藏部分，你就只能用v-show 详情查看官网 vue官网对v-if和v-show的解https://cn.vuejs.org/api/built-in-directives.html#v-show 这个时候，我们找到我们下方导航栏的位置，写入这个代码v-show&#x3D;”!$route.meta.childrenPage” 12345678910111213&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;div class=&quot;foot&quot; v-show=&quot;!$route.meta.childrenPage&quot;&gt; &lt;div class=&quot;footmenu&quot;&gt; &lt;span @click=&quot;goToHome&quot;&gt;&lt;Icon type=&quot;shouye&quot; extraclass=&quot;icon&quot; :class=&quot;&#123; iconActive: isActive == 1 &#125;&quot; /&gt;&lt;/span&gt; &lt;span @click=&quot;goToClassify&quot;&gt;&lt;Icon type=&quot;fenlei1&quot; extraclass=&quot;icon&quot; :class=&quot;&#123; iconActive: isActive == 2 &#125;&quot; /&gt;&lt;/span&gt; &lt;span @click=&quot;goToAbout&quot;&gt;&lt;Icon type=&quot;tuijian&quot; extraclass=&quot;icon&quot; :class=&quot;&#123; iconActive: isActive == 3 &#125;&quot; /&gt;&lt;/span&gt; &lt;span @click=&quot;goToUser&quot;&gt;&lt;Icon type=&quot;user&quot; extraclass=&quot;icon&quot; :class=&quot;&#123; iconActive: isActive == 4 &#125;&quot; /&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 看看效果 下方导航栏成功消失后续出现这些情况都可以照葫芦画瓢了 params的使用博主写到这有点难受，随便写写吧 params也是vue-router的属性之一，使用它可以创建动态路由 vue-router官网对params的解释https://router.vuejs.org/zh/api/interfaces/RouteLocationNormalizedLoaded.html#Properties-params 有的时候，我们需要点击一个按钮，进入子路由，随后显示页面，但是会出现一种情况，如美团的美食界面，很明显都是一样的，只是图片和买哦书有所不同，但是我们会发现，本来它的美食列表就是循环实现的，怎么才能点击进入新路由还可以使用同一个组件呢，使用同一个组件简单，可是我们的router只能有一个，不可能全部美食都是一个路由吧 这个时候就需要我们的动态路由了，可以实时创建路由 这个东西确实对小白不太好描述，因此，我们直接通过一些简单的例子来学习 这个是我们的列表页 其router.js如下 12345&#123; path: &quot;/diet&quot;, name: &quot;diet&quot;, component: () =&gt; import(&quot;../diet/diet.vue&quot;),&#125; 使用了vue-for循环实现了列表的效果，接下来是需要点击不同的卡片进入不同的界面(可以说是相同的界面，当时数据是不同的)效果如下 乌鸡汤酸梅汤 可以看到，除了数据不同，其余样式均一样，因此我们实现这个效果一定是使用了同一个组件巧妙的是，我们路由的显示，又是不一样的，一个是localhost:5173&#x2F;diet&#x2F;虫花草乌鸡汤，一个是localhost:5173&#x2F;diet&#x2F;酸梅汤和我们之前不一样，我们之前的写法只能够一个路由匹配一个组件，现在，我们实现了多个路由匹配一个组件 我们来看一下这个组件的router是怎么写的 12345678&#123; path:&#x27;/diet/:herbsName&#x27;, name:&#x27;herbsPage&#x27;, component:()=&gt;import(&#x27;../components/herbs.vue&#x27;), meta:&#123; childrenPage:true &#125;,&#125; 和以往不同，这次的path在herbsName前面加了一个:这是动态路由的意思，加上:,这个路由就变成了动态的，可以在任何界面操控，赋予任何的值，相当于一个全局变量 知道了这些之后，我们可以这么做，在父组件点击哪个卡片，就跳转组件，同时，将herbsName这个动态这个路由赋值为卡片的名称随后，我们可以在子组件中读取该路由的值（herbsName），在data部分(data在工程中由后端数据库提供，在这里我们导入json文件当作后端)寻找相对应的对象集，将对象集中的数据放在子组件上显示即可 首先，我们看一下父组件的源代码 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;cll&quot;&gt; &lt;div class=&quot;remen&quot; v-for=&quot;item in dietlist&quot; :key=&quot;item.id&quot; @click=&quot;redirectToPage(item.name)&quot;&gt; &lt;div class=&quot;img&quot;&gt; &lt;img :src=&quot;item.img&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;text&quot;&gt; &lt;div class=&quot;zt1&quot;&gt; &lt;div class=&quot;m&quot;&gt;&lt;h3&gt;&#123;&#123; item.name &#125;&#125;&lt;/h3&gt;&lt;/div&gt; &lt;div class=&quot;leibie&quot;&gt;&lt;van-tag :type=&quot;item.color&quot; class=&quot;sss&quot;&gt; &#123;&#123; item.leibie &#125;&#125;&lt;/van-tag&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;zt2&quot;&gt;&lt;p&gt;&#123;&#123; item.gonxiao &#125;&#125;&lt;/p&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;van-back-top bottom=&quot;10vh&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Tag,BackTop &#125; from &#x27;vant&#x27;;export default &#123; components: &#123; vanTag:Tag, vanBackTop:BackTop &#125;, props:&#123; dietlist:&#123; type: Array, required: true, &#125;, &#125;, methods:&#123; redirectToPage(itemName) &#123; // 根据卡片的id进行页面跳转 // 使用Vue Router的例子 this.$router.push(&#123; name: &#x27;herbsPage&#x27;, params: &#123; herbsName:itemName &#125; &#125;); &#125;, &#125;&#125;&lt;/script&gt; 核心在于 12345redirectToPage(itemName) &#123; // 根据卡片的id进行页面跳转 // 使用Vue Router的例子 this.$router.push(&#123; name: &#x27;herbsPage&#x27;, params: &#123; herbsName:itemName &#125; &#125;); &#125; 该函数实现了跳转至名为herbsPage的页面组件的同时将params属性进行修改，将herbsName赋值为通过函数传入的itemName,在这里，itemName也就是卡片的名称（乌鸡汤、酸梅汤等） 接下来我们来看看子组件的源代码,为避免出现不理解的问题，我将json文件也一起放出来 子组件源代码json文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;template&gt; &lt;Header :title=&quot;selectedObject.name&quot;/&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;head&quot;&gt; &lt;span&gt;&#123;&#123; selectedObject.name &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;img :src=&quot;`../$&#123;selectedObject.img&#125;`&quot; alt=&quot;食材图片&quot; class=&quot;img&quot;/&gt; &lt;div class=&quot;cook&quot;&gt; &lt;span class=&quot;listname&quot;&gt;&lt;Icon type=&quot;leaf&quot; extraclass=&quot;icon&quot;/&gt;食材&lt;/span&gt; &lt;div class=&quot;listtext&quot;&gt;&#123;&#123; selectedObject.material &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;cook&quot;&gt; &lt;span class=&quot;listname&quot;&gt;&lt;Icon type=&quot;cook&quot; extraclass=&quot;icon&quot;/&gt;做法&lt;/span&gt; &lt;ol&gt; &lt;li class=&quot;listtext&quot; v-for=&quot;(step, index) in cookSteps&quot; :key=&quot;index&quot;&gt;&#123;&#123; step &#125;&#125;。&lt;/li&gt; &lt;/ol&gt; &lt;video :src=&quot;selectedObject.video&quot; controls&gt;&lt;/video&gt; &lt;/div&gt; &lt;div class=&quot;cook&quot;&gt; &lt;span class=&quot;listname&quot;&gt;&lt;Icon type=&quot;list&quot; extraclass=&quot;icon&quot;/&gt;功效&lt;/span&gt; &lt;div class=&quot;listtext&quot;&gt;&#123;&#123;selectedObject.gonxiao&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;cook&quot;&gt; &lt;span class=&quot;listname&quot;&gt;&lt;Icon type=&quot;warning&quot; extraclass=&quot;icon&quot;/&gt;禁忌&lt;/span&gt; &lt;div class=&quot;listtext&quot;&gt;&#123;&#123; selectedObject.taboo &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height: 30px;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Icon from &#x27;./icon.vue&#x27;import jsonData from &#x27;../json/herbslist.json&#x27;import Header from &#x27;./backHead1.vue&#x27;export default &#123; components: &#123; Header,Icon &#125;, data()&#123; return&#123; selectedObject: &#123;&#125;, &#125; &#125;, computed: &#123; cookSteps() &#123; if (this.selectedObject.cook) &#123; return this.selectedObject.cook.split(&#x27;。&#x27;).filter(step =&gt; step.trim() !== &#x27;&#x27;); &#125; return []; &#125; &#125;, created()&#123; this.loadCardData(); &#125;, methods: &#123; loadCardData() &#123; const herbsName = this.$route.params.herbsName; // 你可以根据实际情况使用异步请求加载数据 setTimeout(() =&gt; &#123; // 根据herbsName加载对应卡片的数据，这里只是示例 let selectedObject = jsonData.find(obj =&gt; obj.name == herbsName); if (selectedObject) &#123; this.selectedObject = selectedObject; &#125; else &#123; console.error(&#x27;未找到匹配的对象&#x27;); &#125; &#125;, 500); // 模拟异步加载的延迟 &#125;, &#125;,&#125;&lt;/script&gt;123456789101112131415161718192021222324252627282930[ &#123;&quot;id&quot;: 1,&quot;value&quot;:&quot;10&quot;, &quot;name&quot;: &quot;虫草花乌鸡汤&quot;, &quot;gonxiao&quot;: &quot;止血化痰·益肝补肾，养气补精&quot;, &quot;img&quot;: &quot;./wjt.jpg&quot;, &quot;leibie&quot;: &quot;汤类&quot;, &quot;color&quot;: &quot;primary&quot;, &quot;video&quot;: &quot;../wjt.mp4&quot;, &quot;material&quot;: &quot;乌鸡1只，虫草花10克，姜片3片，料酒1汤匙，盐适量。&quot;, &quot;cook&quot;: &quot;1.乌鸡去毛、内脏、洗净，切块，用开水焯一下，捞出洗净。2.虫草花洗净，用开水焯一下，捞出洗净。3.将乌鸡块、虫草花、姜片、料酒放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。4.加入盐调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 2,&quot;value&quot;:&quot;9&quot;, &quot;name&quot;: &quot;酸梅汤&quot;, &quot;gonxiao&quot;: &quot;除热送凉、生津止漏、祛痰止渴&quot;, &quot;img&quot;: &quot;./smt.jpg&quot;, &quot;leibie&quot;: &quot;汤类&quot;, &quot;color&quot;: &quot;primary&quot;, &quot;video&quot;: &quot;../smt.mp4&quot;, &quot;material&quot;: &quot;酸梅干10克，冰糖适量，水适量。&quot;, &quot;cook&quot;: &quot;1.酸梅干洗净，用开水焯一下，捞出洗净。2.将酸梅干放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。3.加入冰糖调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 3,&quot;value&quot;:&quot;3&quot;, &quot;name&quot;: &quot;薄荷粥&quot;, &quot;gonxiao&quot;: &quot;疏散风热.清利咽喉&quot;, &quot;img&quot;: &quot;./bhz.jpg&quot;, &quot;leibie&quot;: &quot;粥类&quot;, &quot;color&quot;: &quot;success&quot;, &quot;video&quot;: &quot;../bhz.mp4&quot;, &quot;material&quot;: &quot;大米100克，薄荷叶10克，冰糖适量，水适量。&quot;, &quot;cook&quot;: &quot;1.大米淘洗干净，薄荷叶洗净。2.将大米、薄荷叶放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。3.加入冰糖调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 4,&quot;value&quot;:&quot;6&quot;, &quot;name&quot;: &quot;金橘茶&quot;, &quot;gonxiao&quot;: &quot;消积止呕&quot;, &quot;img&quot;: &quot;./jjc.jpg&quot;, &quot;leibie&quot;: &quot;茶类&quot;, &quot;color&quot;: &quot;warning&quot;, &quot;video&quot;: &quot;../jjc.mp4&quot;, &quot;material&quot;: &quot;金橘1个，冰糖适量，水适量。&quot;, &quot;cook&quot;: &quot;1.金橘洗净，切片。2.将金橘片放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。3.加入冰糖调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 5,&quot;value&quot;:&quot;16&quot;, &quot;name&quot;: &quot;人参酒&quot;, &quot;gonxiao&quot;: &quot;补气，活血驱寒&quot;, &quot;img&quot;: &quot;./rsj.jpg&quot;, &quot;leibie&quot;: &quot;酒类&quot;, &quot;color&quot;: &quot;danger&quot;, &quot;video&quot;: &quot;../rsj.mp4&quot;, &quot;material&quot;: &quot;人参10克，白酒500克。&quot;, &quot;cook&quot;: &quot;1.人参洗净，切片。2.将人参片放入瓶中，加入白酒，密封放置1个月即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 6,&quot;value&quot;:&quot;18&quot;, &quot;name&quot;: &quot;金银花茶&quot;, &quot;gonxiao&quot;: &quot;清热解毒&quot;, &quot;img&quot;: &quot;./jyhc.jpg&quot;, &quot;leibie&quot;: &quot;茶类&quot;, &quot;color&quot;: &quot;warning&quot;, &quot;video&quot;: &quot;../jyhc.mp4&quot;, &quot;material&quot;: &quot;金银花10克，冰糖适量，水适量。&quot;, &quot;cook&quot;: &quot;1.金银花洗净。2.将金银花放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。3.加入冰糖调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;, &#123;&quot;id&quot;: 7,&quot;value&quot;:&quot;1&quot;, &quot;name&quot;: &quot;蜂蜜柚子茶&quot;, &quot;gonxiao&quot;: &quot;清热解毒&quot;, &quot;img&quot;: &quot;./fmyzc.jpg&quot;, &quot;leibie&quot;: &quot;茶类&quot;, &quot;color&quot;: &quot;warning&quot;, &quot;video&quot;: &quot;../fmyzc.mp4&quot;, &quot;material&quot;: &quot;柚子1个，蜂蜜适量，水适量。&quot;, &quot;cook&quot;: &quot;1.柚子洗净，切片。2.将柚子片放入砂锅中，加入适量清水，大火煮沸后转小火炖2小时。3.加入蜂蜜调味即可。&quot;, &quot;taboo&quot;: &quot;脾胃虚寒者、痰湿者不宜多食。&quot;&#125;] 在子组件源代码中，我们在生命周期函数中调用了loadCardData函数 12345678910111213loadCardData() &#123; const herbsName = this.$route.params.herbsName; // 你可以根据实际情况使用异步请求加载数据 setTimeout(() =&gt; &#123; // 根据herbsName加载对应卡片的数据，这里只是示例 let selectedObject = jsonData.find(obj =&gt; obj.name == herbsName); if (selectedObject) &#123; this.selectedObject = selectedObject; &#125; else &#123; console.error(&#x27;未找到匹配的对象&#x27;); &#125; &#125;, 500); // 模拟异步加载的延迟&#125; 该函数很简单，获取当前路由的params属性值，就是路由的herbsName值,随后将这个值在json中进行查找，并将该值所在的对象提取出来并赋给selectedObject，然后我们就可以对selectedObject随便操控了，接下来的事情就是一马平川了 ok了家人们 本文就此结束，有需要可以联系邮箱：&#50;&#x30;&#56;&#52;&#56;&#57;&#54;&#x33;&#x30;&#49;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;微信：wxcf9687","categories":[],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://blog.gavinccc.com/tags/VUE/"},{"name":"ElementUI","slug":"ElementUI","permalink":"http://blog.gavinccc.com/tags/ElementUI/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.gavinccc.com/tags/yarn/"},{"name":"node.js","slug":"node-js","permalink":"http://blog.gavinccc.com/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://blog.gavinccc.com/tags/npm/"},{"name":"html","slug":"html","permalink":"http://blog.gavinccc.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://blog.gavinccc.com/tags/css/"}]},{"title":"VScode配置C51环境","slug":"VScode_create_C51","date":"2024-01-27T17:19:23.000Z","updated":"2024-02-26T08:38:12.945Z","comments":true,"path":"2024/01/28/VScode_create_C51/","permalink":"http://blog.gavinccc.com/2024/01/28/VScode_create_C51/","excerpt":"使用Embedded IDE在vscode上部署keil c环境，一举解决keil开发难受的问题vscode，爽！","text":"使用Embedded IDE在vscode上部署keil c环境，一举解决keil开发难受的问题vscode，爽！ 基于Embedded IDE在vscode上配置C51环境 入手51单片机，绕不开一款软件–keil，它内置了非常多芯片的配置，几乎是最全面的软件，也是很多嵌入式工程师的第一选择，然而几乎入手keil的每个人都会抱怨，已经什么年代了，怎么界面还是这么古老，而且支持的更改少，无代码补全功能，种种缺点另许多程序员苦不堪言，我亦是如此 要是能够在vscode上开发就好了，世界上最丰富的插件市场，酷炫的界面，强大github copilot等ai代码辅助工具，真是令人欲罢不能 这个时候，我突然想到，我在vscode上配置了这么多环境（c&#x2F;c++、python、vue、node.js等等数不胜数），一定可以配置C51吧，在网上一搜，哦~其实嵌入式开发使用vscode已成常态，不过基本都是32之后，使用vscode配置c51还是少部分，找了许多种方法，终于找到一个非常适合自己的 以下就是详细的配置教程 1.下载vscode，直接搜索下载即可，需要注意的是下载系统版的 2.在vscode中安装插件Embedded IDE，安装时间较长，等一会咯 3.打开keil C51的安装目录，找到TOOLS.INI文件并记住该文件路径 4.打开vscode点开左侧菜单栏Embedded IDE图标打开插件然后点击操作，点击设置工具链路径，设置刚刚看过的TOOLS.INI文件 点开后选择keil的TOOLS.INI文件 看到这其实你也明白了吧，实际上也是调用了keil的接口罢了 5.设置完成后就可以点击新建项目或者导入keil项目，新建项目点击之后选择空项目，选择8位MCU，，随后命名完就创建成功了 6.创建好之后在创建好的项目目录下点击构建配置并换成keil C51 7.src目录就是存放代码的目录，在这里会有一个main.c文件，现在已经可以正常的写代码了 也可以点击左侧菜单栏Embedded IDE图标来打开src目录（这样更容易看工程目录） 8.在右上角点击构建图标即可编译 9.编译通过会在build目录生成hex文件，这样就可以正常烧录了 10.再次打开只需选择工程的code-workspace文件即可 也可以打开老keil项目 也是可以正常烧录 理论上来说stm32与arduino都可以使用，不过在面对不同的环境时，可能会有更好的方法，没关系，遇水搭桥，逢山修路，要是遇到更好的方法，后续会有更新","categories":[],"tags":[{"name":"VScode","slug":"VScode","permalink":"http://blog.gavinccc.com/tags/VScode/"},{"name":"Embedded IDE","slug":"Embedded-IDE","permalink":"http://blog.gavinccc.com/tags/Embedded-IDE/"}]},{"title":"3D建模","slug":"3D_model","date":"2023-07-11T14:53:32.000Z","updated":"2024-02-26T08:38:12.945Z","comments":true,"path":"2023/07/11/3D_model/","permalink":"http://blog.gavinccc.com/2023/07/11/3D_model/","excerpt":"Soildworks安装教程","text":"Soildworks安装教程 安装包获取SolidWorks2021 详细安装教程，百度网盘链接：https://pan.baidu.com/s/1UUAsVRxzJ0ga7q654ZGp7Q提取码：jlbp 安装步骤step1 解压压缩文件：压缩密码为rjzkgzh双击运行，点击是，点击确定。注册表注册成功后 step2 解压完成，在D:\\Soildworks2021\\SW21_CN_x64\\SW21_CN_x64\\SW21_CN_x64_SolidSQUAD_目录下找到 step3 继续在该目录下然后在C盘或D盘（最好在C盘）新建一个SolidWorks文件夹存放，并双击打开该文件夹，然后 step4 断开网络，关闭防火墙等安全防护 step5 在解压后的文件夹中找到双击进入：找到setup文件默认下一步后，在此处下一步在检索的时候一定要断开网络提示：点击取消后进入下一步可以更改安装目录，文件比较大安装完成后：不要运行软件 step6（直接看下方更改路径后的操作） 若是自己更改过安装路径，双击打开压缩包解压后的“SolidWorks2020”文件夹里面的“SolidSQUAD”文件夹，双击打开“Program Files”文件夹，双击打开“SOLIDWORKS Corp”文件夹，全选“SOLIDWORKS Corp”文件夹中的所有内容，然后鼠标右击选择“复制”。复制后找到安装路径下的粘贴替换即可 step7 双击打开压缩包解压后的“SolidWorks2020”文件夹里面的“SolidSQUAD”文件夹，双击“SolidSQUADLoaderEnabler” 上文来源CSDN","categories":[],"tags":[{"name":"3D建模","slug":"3D建模","permalink":"http://blog.gavinccc.com/tags/3D%E5%BB%BA%E6%A8%A1/"}]},{"title":"从51到32","slug":"51to32","date":"2023-07-08T01:52:35.000Z","updated":"2024-02-26T08:38:12.946Z","comments":true,"path":"2023/07/08/51to32/","permalink":"http://blog.gavinccc.com/2023/07/08/51to32/","excerpt":"从51到32 一段嵌入式开发的学习过程 开始旅程","text":"从51到32 一段嵌入式开发的学习过程 开始旅程 c语言程序入门应用关键字与数据类型 #include &#x3D;&gt; 包含头文件头文件预处理在源文件与编译器之间#define &#x3D;&gt; 宏定义一般在头部，将c中某关键字进行替换 32个关键字，编译器预先定义了有一定物理意义的字符串 &#x3D;&gt;不同编译器有不&gt;同的定义sizeof 也是关键字:查看变量在内存空间中容量的工具，用法sizeof(变量)通&gt;过关键字定义的不同数据类型的变量，限制变量 (资源)的大小(e.g.4字节，2字节…) c中的数据类型有明确规范，无论输入还是输出都要标明 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x, %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 把输出的值按照 %e 或者 %f 类型中输出长度较小的方式输出 %p 输出地址符 %lu 32位无符号整数 %llu 64位无符号整数 %% 输出百分号字符本身。 除了格式化说明符之外，printf() 函数还支持一些标志和选项，用于控制输出的精度、宽度、填充字符和对齐方式等。 例如： %-10s：左对齐并占用宽度为 10 的字符串； %5.2f：右对齐并占用宽度为 5，保留两位小数的浮点数； %#x：输出带有 0x 前缀的十六进制数。 局部变量、全局变量、静态变量对于单一文件而言的:局部变量、全局变量、静态变量 局部变量:定义在函数内部的变量&#x3D;&gt;代码块作用域全局变量:定义在函数外部的变量&#x3D;&gt;文件作用域静态变量:有static修饰的变量有很多种组合，不需要都搞清楚，等遇到了再分析: where (可见性)?&amp; static (生命周期)? 下面这个例子很好的展示了这一点并且展示了冒泡排序示例 123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;int main()&#123; int class[10]; for (int i = 0; i &lt; 10; i++) // 循环输入10次 &#123; scanf(&quot;%d&quot;,&amp;class[i]); &#125; printf(&quot;你输入了：&quot;); for (int j = 0; j &lt; 10; j++) //遍历数组并输出 &#123; printf(&quot;%d &quot;,class[j]); &#125; for (int i = 0; i &lt; 10; i++) //冒泡排序 &#123; for (int j = 0; j &lt; 10; j++) &#123; if (class[j+1]&gt;class[j]) &#123; int null = class[j]; class[j] = class[j+1]; class[j+1] = null; &#125; &#125; &#125; printf(&quot;\\n&quot;); for (int j = 0; j &lt; 10; j++) //遍历排序好的数组并输出 &#123; printf(&quot;排第%d的数是%d\\n&quot;,j+1,class[j]); &#125; &#125; 卧槽无语了，刚开始写的博客，这个代码应该是上一章节的 数组例：char a[num]&#x3D;{……} 当char中使用中文时，应该是二维数组 1char wday[7][7] = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;&#125;; 注意事项 int a[]&#x3D;{……}; 可以在定义的时候给出初始值。可省略。int b[][5]&#x3D;{…}; 同上，但是第二个不能省略a[]&#x3D;3; 这样做就不对了，里面没有定位，不能省略。b[][2]&#x3D;2; 同上，不能省略。 a[x]&#x3D;3；这样做也对，但是要保证变量x的值正确。C不会自动给你查越界。 以下例子很好的展示数组 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;void main()&#123; int tick = 0; //0~86399 short mouth[12] = &#123;31,29,31,30,31,30,31,31,30,31,30,31&#125;; short date; short yue; short week; char wday[][7] = &#123;&quot;星期一&quot;,&quot;星期二&quot;,&quot;星期三&quot;,&quot;星期四&quot;,&quot;星期五&quot;,&quot;星期六&quot;,&quot;星期天&quot;&#125;; printf(&quot;请输入一个在 1~366 区间的数\\n&quot;); scanf_s(&quot;%d&quot;, &amp;tick); week = (tick+8)%7 ; //这个应该不会错的 date = tick; for (int i = 0; i &lt; 12; i++) //依次遍历，一旦小于等于0，则该次遍历为月份 &#123; tick = tick - mouth[i]; if (tick&lt;=0)&#123;yue=i+1;break;&#125;; &#125; for (int j = 0; j &lt; yue; j++) //遍历之后获得减掉前面月份天数的值，即为当月日期 &#123; date= date-mouth[j-1]; &#125; printf(&quot;当前日期为: 20-%02d-%02d-%s\\n&quot;, yue, date, wday[week]); &#125; 枚举说实话还是不太理解 枚举方法： 1、先定义枚举类型，再定义枚举变量 12345enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;;enum DAY day; 这里的DAY是枚举名 2、定义枚举类型的同时定义枚举变量 1234enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125; day; 3、省略枚举名称，直接定义枚举变量 1234enum&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125; day; 可以使用typedef定义别名 12345typedef enum&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125; day;day day1 day2; 其中day是这个枚举名的别名，提高代码可读性 下面这串代码很好的展示了枚举的应用 1234567891011121314#include &lt;stdio.h&gt; enum DAY&#123; MON=1, TUE, WED, THU, FRI, SAT, SUN&#125;; int main()&#123; enum DAY day; day = WED; printf(&quot;%d&quot;,day); return 0;&#125; 枚举经常与switch一同使用下面的代码展示了这种情况 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main()&#123; enum color &#123; red=1, green, blue &#125;; enum color favorite_color; /* 用户输入数字来选择颜色 */ printf(&quot;请输入你喜欢的颜色: (1. red, 2. green, 3. blue): &quot;); scanf(&quot;%u&quot;, &amp;favorite_color); /* 输出结果 */ switch (favorite_color) &#123; case red: printf(&quot;你喜欢的颜色是红色&quot;); break; case green: printf(&quot;你喜欢的颜色是绿色&quot;); break; case blue: printf(&quot;你喜欢的颜色是蓝色&quot;); break; default: printf(&quot;你没有选择你喜欢的颜色&quot;); &#125; return 0;&#125; 补充 在所有教科书与c规范中，switch都是不允许case后接范围的，但是GNU C进行了扩展可以使用case min … max这种用法表示范围（英文句号，前后有空格） 示例 123456789101112131415#include&lt;stdio.h&gt;int main()&#123; int i; scanf( &quot;%d&quot;,&amp;i); switch (i) &#123; case 1 ... 3: printf(&quot;niubi\\n&quot;); break; default: break; &#125;&#125; 指针C语言中几乎最重要的地方来了，难度较大，必须掌握 指针是什么1234567891011#include &lt;stdio.h&gt; int main ()&#123; int var_runoob = 10; int *p; // 定义指针变量 p = &amp;var_runoob; printf(&quot;var_runoob 变量的地址： %p\\n&quot;, p); return 0;&#125; &amp;取址*取值 数组名即指针！！ 指针控制数组 数组与指针关于指针，内含的奥妙非常多，其中非常知名的就是数组即指针数组是指针的另一种表示我们可以这么看： 12345int main()&#123; char a[3]= &quot;123&quot;; printf(&quot;%c&quot;,*(a+2));&#125; 在这里面定义了一个字符串数组，但是我调用他的方式却是使用了指针数组名就是一个指针常量，这里a的值是数组a[3]的首元素的地址于是，我们可以这样： 12345int main()&#123; char *a = &quot;123&quot;; printf(&quot;%c&quot;,a[2]);&#125; 与上面的代码并不会出现差别 多重指针可以定义一个指向指针的指针 123456int main()&#123; int a = 1; int *p = &amp;a; int **p2 = &amp;p;&#125; 以此为准可以不断叠加指针，完成许多复杂的功能 结构体与枚举有点相似为了使有关联性的变量变得更加易控，也为了提高可读性，结构体因此而生 结构体定义 1234567struct Stuructstudent&#123; int num; char name; char sex; int age&#125;;//声明结构体Structstudent student1;//定义变量 实际上结构体就是一种数据类型，只不过是由程序员自己定义的在实际生活中，我们会有各种各样的数据类型，如图书的名、ISBN、价格等可以集合为一个数据类型 123456789int main()&#123; struct book&#123; int isbn; char name[10]; double price; &#125;; book b3= &#123;&quot;活着&quot;,111111111,39&#125;;&#125; 注意 需要注意的是，结构体中内存的分配是由结构体的中定义的变量占用的内存决定的但是但是它却遵循整除内存原则，如上述的代码中首先，计算机会找到一个可以被4（int的长度）整除的内存地址（如2000）然后在2004后面找到可以被10（name数组的长度）整除的地址（如2010）最后在在2020后面找到可以被8（double的长度）整除的地址（如2024）最后还要将首末相连空隙进行填充，一共是32字节的长度，整体的长度还必须是结构里最大数据类型的长度的整数倍（这里是double的长度8的整数倍）如果不是还要在后面进行填充（假如是36，就要填充到40）所以在结构体中数据类型的定义的先后十分重要在上述代码中只需要将isbn和name调换顺序就只需要24字节的空间 51单片机硬件设备与软件环境单片机 stc89c52rc 软件环境 Visual studio code + Embedded IDE + keil c(点击跳转部署教程)外设 按钮*3 4位数码管*1 led*4 蜂鸣器*1 看门狗*1 12mhz晶振 usbin 注意 看芯片手册是一个非常重要的习惯我们做的无非就是复现手册的内容而已此篇章只保留作者认为重要的单片机知识 IO口的使用无需多言，上代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;REG52.H&gt;#include &quot;Delay.h&quot;sbit led1=P2^4;sbit led2=P2^5;sbit led3=P2^6;sbit led4=P2^7;void main()&#123; while(1)&#123; led1 = 0; Delay(500); //led1 = 1; led2 = 0; Delay(500); //led2 = 1; led3 = 0; Delay(500); //led3 = 1; led4 = 0; Delay(500); //led4 = 1; led1 = 1; Delay(500); //led1 = 1; led2 = 1; Delay(500); //led2 = 1; led3 = 1; Delay(500); //led3 = 1; led4 = 1; Delay(500); //led4 = 1; &#125; &#125; 这是最简单的led流水灯效果，所有入门51的必备IO口的控制流程如下1.查看需要控制的外设的对应单片机的引脚2.使用sbit定义引脚名（如led1）3.为引脚编写1或0来控制引脚 按键的防抖我甚至不知道要不要给它单独开一个章节 我们使用按钮的时候一般使用判断 12345while(1)&#123; if（key1 == 1）&#123; //代码区 &#125;&#125; 然而造成的结果是，我们明明只想要一次运行，但是由于单片机速度太快，会造成非常多次运行因此，我们需要防抖 12345678while(1)&#123; if(key1 == 1)&#123; delay(20);//延迟看个人而定 if(key1 == 1)&#123; //代码区 &#125; &#125;&#125; 只需要一个简单延迟函数就完成了防抖 注意 不过，在较为大的工程中，延迟非常容易造成工程总体运行的堵塞情况同时，延迟也无法很好的避免多次运行的问题因此，在后续的工程开发中我们使用外部中断来实现按钮功能外部中断是异步的（异步是计算机与电子信息中非常重要的概念） 数码管显示数码管实现原理：请回顾数字电路技术课程 无需多言，上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;REGX52.H&gt;#include &quot;Delay.h&quot;sbit key1=P3^2;sbit key2=P3^3;sbit key3=P3^4;//数码管段码表unsigned char NixieTable[]=&#123;0x03,0x9F,0x25,0x0D,0x99,0x49,0x41,0x1F,0x01,0x09&#125;;//数码管显示子函数void Nixie(unsigned char Location,Number)&#123; switch(Location) //位码输出 &#123; case 1:P2=0x7;break; case 2:P2=0xB;break; case 3:P2=0xD;break; case 4:P2=0xE;break; &#125; P0=NixieTable[Number]; //段码输出 Delay(1); //显示一段时间 P0=~0x0; //段码清0，消影&#125;void main()&#123; unsigned char x = 0; unsigned char y = 0; unsigned char z = 0; while(1) &#123; if(key1 ==0) &#123; Delay(80); if(key1 == 0) &#123; x++; if(x&gt;9) &#123; x = 0; y++; if(y&gt;9) &#123; y=0; z++; &#125; &#125; &#125; &#125; Nixie(1,1); //在数码管的第1位置显示1// Delay(20); Nixie(2,2); //在数码管的第2位置显示2// Delay(20); Nixie(3,3); //在数码管的第3位置显示3// Delay(20); Nixie(4,4); //在数码管的第4位置显示4// Delay(20); &#125;&#125; 流程1.弄清楚每个数字对应在数码管上的位置2.位置的二进制表示3.二进制转16进制4.每一个数码管的启动方式（需让其他数码管关，否则出现全亮，使用延迟实现单独亮）5.打包成函数，方便调用 外部中断外部中断的定义与产生机理定义 外部中断是单片机实时地处理外部事件的一种内部机制。当某种外部事件发生时，单片机的中断系统将迫使CPU暂停正在执行的程序，转而去进行中断事件的处理；中断处理完毕后．又返回被中断的程序处，继续执行下去。 换而言之 我外部中断只要一开，你单片机就先把手中的事放放，先办我的事（领导既视感） 产生机理 单片机在自主运行时一般是在执行一个死循环程序，在没有外界干预(输入信号)时它基本处于一个封闭状态。比如一个电子时钟，它会按时、分、秒的规律自主运行并通过输出设备(如液晶显示屏)把时间显示出来。在不需要对它进行调校时它不需要外部干预，自主封闭地运行。如果这个时钟足够准确而又不掉电的话，它可能一直处于这种封闭运行状态。但事情往往不会如此简单，在时钟刚刚上电或时钟需要重新校准．甚至时钟被带到不同时区的时候，就需要重新对时钟进行调校，这时就要求时钟必须具有调校功能。因此单片机系统往往又不会是一个单纯的封闭系统．它有些时候恰恰需要外部的干预，这也就是外部中断产生的根本原因。 在没有干预的情况下，单片机的程序在封闭状态下自主运行，如果在某一时刻需要响应一个外部事件(比如有按键按下)，这时就会用到外部中断。具体来讲，外部中断就是在单片机的一个引脚上，由于外部因素导致了一个电平的变化(比如由高变低)，而通过捕获这个变化，单片机内部自主运行的程序就会被暂时打断，转而去执行相应的中断处理程序，执行完后又回到原来中断的地方继续执行原来的程序。这个引脚上的电平变化，就申请了一个外部中断事件，而这个能申请外部中断的引脚就是外部中断的触发引脚。 以上来源于科普中国 外部中断的使用以代码来解释 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;REG52.H&gt;sbit LED1 = P2^4;sbit BEEP = P1^0;void Delay(unsigned int xms)&#123; unsigned char i, j; while(xms--) &#123; i = 2; j = 239; do &#123; while (--j); &#125; while (--i); &#125;&#125;void InitInterrupt()&#123; IT0 = 0;//低电平触发 EX0 = 1;//外部中断1启动 PX0 =1;//外部中断1优先级高 EA= 1;//总中断&#125;int main()&#123; InitInterrupt(); while(1) &#123; BEEP = 1; Delay(10); BEEP = 0; &#125;&#125;void openled1() interrupt 0&#123; LED1 = 0; BEEP = 0;&#125; 这个代码不按按钮的话就会持续的蜂鸣器开关，只要一按就会实现一直开 只要按钮一按，中断启动，你主程序，往后稍稍，先干活先搞我的 在函数后面加上interrupt 0表示这个函数是外部中断1中断时运行的函数interrupt后面的数字，根据下面的表格的中断编号 中断编号 中断名称 中断请求标志位 中断允许控制位 触发条件 0 外部中断0 IE0 EX0 中断0对应的引脚检测到下降沿或低电平 1 定时器0 TF0 ET0 定时器0溢出 2 外部中断1 IE1 EX1 中断1对应的引脚检测到下降沿或低电平 3 定时器1 TF1 ET1 定时器1溢出 4 串口中断 RI,TI ES 串口接收或发送一帧数据 5 定时器2 TF2 ET2 定时器2溢出 6 外部中断2 IE2 EX2 中断2对应的引脚检测到下降沿或低电平 7 外部中断3 IE3 EX3 中断3对应的引脚检测到下降沿或低电平 中断优先级优先级在代码里面也有注释，使用PX0就可以让外部中断0优先级变高 默认的优先级是按照中断编号从小到大依次递减的PX(X)H、PX(X)可以定义外部中断优先级PT(X)H、PT(X)可以定义定时器优先级PSH、PS可以定义串口优先级 定时器定时器工作原理和外部中断一样，定时器也是异步的 定时器的执行，，不会依靠cpu的资源，它是独立运行的，独立于cpu的外部计数器，它的计数时长依赖于时钟周期，时钟周期是晶振频率的倒数（计数的间隔的时长的来源），通过设定不同的初值实现不同的时间间隔 和外部中断一样，它的也是异步的，运行完至后可以产生中断，这样，就可以实现非阻塞式的延迟（在主进程中延迟会阻碍其他函数的运行） 就像你正在吃饭，一边又在给水桶里放水，吃着吃着，水满了，你就得赶快去把水龙头关掉或者换一个空的水桶，再回来吃饭。单片机的定时器就像是一个水桶，你让它启动了，也就是水龙头打开了；开始装水了；定时在每个机器周期不断自动加 1，最后溢出了；水桶的水不断增加，最也就满出来了；定时器溢出时，你就要去做处理了；水桶的水满了，你也应该处理一下了；处理完后，单片机又可以回到刚刚开停止的地方继续运行；水桶处理了，先前你在做什么也可以继续去做什么了。 计数初值与计时时长在单片机中，计数初值与计数时长之间的关系可以通过计时器的工作原理来解释。通常情况下，计时器是由一个时钟源提供时钟脉冲，计数器根据这些脉冲进行计数。计数初值决定了计数器的初始值，而计数时长则是计数器从初始值开始计数到达最终值所经过的时钟脉冲数。 假设计数器的时钟源频率为 $$ (f_{clk}) $$，计数初值为$$ (N_{initial}) $$，计数器的最大计数值为$$ (N_{max}) $$，那么计数时长$$ (T) $$与计数初值$$ (N_{initial}) $$之间的关系可以用下面的公式表示： $$[ T &#x3D; \\frac{(N_{max} - N_{initial} + 1)}{f_{clk}} ]$$ 然而我们定义计数初值有tl和th而且是使用16进制，这该怎么计算呢？ 跟着我的步骤，轻松算出来！ 1.将 TH 和 TL 合并为一个16位的值，假设 TH 为高8位，TL 为低8位。2.将这个16位的值转换为10进制，得到计数初值的实际数值。3.使用计数初值的实际数值代入计时器的时钟频率，根据时钟频率计算出对应的时间。 如果时钟频率是12MHz，那么使用之前提到的计数初值 TH 和 TL，合并为 16 位的值，然后将其转换为10进制。假设合并后的值为 0xABCD（TH 为 0xAB，TL 为 0xCD），那么按照之前的步骤，将 0xABCD 转换为10进制。得到43981。 接着，使用时钟频率 12MHz（12,000,000Hz），可以使用以下公式计算对应的时间：$$[ T &#x3D; \\frac{65536 - 43981}{12,000,000} ]$$这将给出计数初值对应的时间，单位为秒。 定时器的使用ok话不多说上代码！！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;REG52.H&gt;sbit led1 = P2^4;sbit beep = P1^0;sbit key1=P3^2;//数码管段码表unsigned char NixieTable[]=&#123;0x03,0x9F,0x25,0x0D,0x99,0x49,0x41,0x1F,0x01,0x09&#125;;unsigned char x = 0;unsigned char y = 60;void Delay(unsigned int xms)&#123; unsigned char i, j; while(xms--) &#123; i = 2; j = 239; do &#123; while (--j); &#125; while (--i); &#125;&#125;//数码管显示子函数void Nixie(unsigned char Location,Number)&#123; switch(Location) //位码输出 &#123; case 1:P2=0x7;break; case 2:P2=0xB;break; case 3:P2=0xD;break; case 4:P2=0xE;break; &#125; P0=NixieTable[Number]; //段码输出 Delay(1);//显示一段时间 P0=~0x0; //段码清0，消影&#125;void InitInterrupt()&#123; IT0 = 0; EX0 = 1; PX0 =1; ET0 = 1; EA = 1;&#125;void openled1() interrupt 0&#123; y = 60;&#125;void timer()&#123; TMOD = 0x01; TH0 = 0xFC; TL0 = 0x18; TR0 = 1;&#125;void timerhandle() interrupt 1&#123; unsigned int icount; TH0 = 0xFC; TL0 = 0x18; icount++; if(icount &gt;= 1000) &#123; icount = 0; y--; if(y == 0) &#123; y = 0; beep = 0; &#125; &#125;&#125; void main()&#123; InitInterrupt(); timer(); while(1) &#123; Nixie(1,0); //在数码管的第1位置显示1 Nixie(2,0); //在数码管的第2位置显示2 Nixie(3,y/10); //在数码管的第3位置显示3 Nixie(4,y%10); &#125;&#125; 该代码实现了一个简单的秒表（虽然只有秒针） 这里计数应该是1毫秒的时间间隔，使用icount变量的累加实现1秒 interrupt 1所在的函数就是定时器计数溢出函数 TMOD定义了该定时器为工作模式1，16位计数器 学到这，参透这个代码是起码的 快速计算定时时长根据上面的公式，我们可以算出需要定时的时长，可是，我懒啊，算不了了啊，脑子不够啊其实，硬件公司都做好了，我们直接用就好了 懒人启动器，启动！ 以这个单片机的公司为例，人家早就把定时器的计算接口放在烧录软件了 我们打开烧录软件，点开这个按钮定时器计算器就可以看到以下画面 嘿嘿，只要我们轻轻的点几个按钮，就可以生成对应时长的代码了 值得注意的是，单片机型号、时钟频率不要选错哦 对了，我们这个单片机集成板的晶振是12mhz的 串口通信嗨，好多呀写不下去了累死了 并行通信与串行通信并行通信当我们在一个机器传一个数据给另外一个机器的时候,我们是怎么传的呢？ 你可能第一时间想到计算机是二进制的，我们要先将数据转为二进制（编码，请回顾数电课程），这是对的比如一个数字9，二进制表示为1001，我们要传1001 我们怎么传1001呢？ 你可能会想到，诶！拿4条线把2个机器接起来，同一时间内，低电平表示0，高电平表示1，这样，就可以把1001作为电平信号传过去了，只要在另外的机器将二进制转为十进制（译码，请回顾数电课程）即可。 那么，恭喜你，你已经理解了并行通信 如上图所示，只要将1001按顺序放在D1,D2,D3,D4即可，需要注意的是，必须要同一时段发送与接收这就是并行通信，速度快，好理解但是问题也接踵而来如果我要发送非常多的数据，岂不是要非常多的线？我哪有这么多钱买线因此，串行通信！ 串行通信为了解决线路多，不好操控的问题，串行通信应运而生，什么是串行通信呢，其实就是一条线传多个数据好的，你来想想怎么实现一条数据线怎么传多个数据呢？ 你可能会想到，欸一段时间只传一位数据不就好了吗，然后一直传，直到传完，比如传1001.我就先传一个1，然后再传两个0，最后来个1完事，接收端再拼成一整个1001即可 这么看，你真的是天才，你又把串行通信给领悟了 整体思路就是这样了，只要固定好每一位数据的发送时间，接收端按照约定好的时间接收数据，即可完成通信 如图所示，将1001放在D数组中，一位一位的发送，一位一位的接收，即可完成通信同步和异步串行通信的区别是异步没有时钟线需要注意的是，每一位发送的时间间隔必须相同 单工、半双工、全双工数据传输单工 一条线，单方向传输 半双工 一条线，双方向传输 全双工 单方向传输，但是两条线 UART协议UART协议就是串口通信的协议，是异步串行全双工通信协议 1.异步性： UART是一种异步协议，即发送和接收端不共享时钟信号。相对于同步协议，UART不需要发送和接收端保持精确的时钟同步，因此更为灵活。 2.数据帧： UART通信以数据帧的形式传输数据。数据帧包括起始位（Start Bit）、数据位（通常为8位，可以是5到9位）、可选的奇偶校验位（Parity Bit，用于错误检测）、停止位（Stop Bit）。起始位和停止位的作用是标识数据帧的开始和结束。 3.波特率： 波特率（Baud Rate）是衡量UART通信速率的单位，表示每秒传输的比特数。波特率定义了数据信号的传输速率，发送和接收端必须使用相同的波特率才能正常通信。 4.起始位和停止位： 起始位通常是逻辑 0，用于指示数据帧的开始。停止位是逻辑 1，用于指示数据帧的结束。数据帧的每一位都以起始位开始，以停止位结束。 数据传输流程： 发送端：将数据位、奇偶校验位、起始位和停止位按照帧的格式组成数据帧，通过TXD发送。接收端：通过检测RXD起始位的开始，开始接收数据。接收端根据帧的格式提取数据位、奇偶校验位、停止位等信息。 知道这些东西，我们就可以想象一下传输的过程了 1.固定好时间间隔，也就是固定好波特率2.发送起始位3.根据数据发送数据的每一位4.发送结束位表示发送结束 假设我要发送115首先我们将115转化为二进制，即01110011使用代码设定好波特率给发送0表示开始发送（就是将TXD设为0）时间宽度走完后给TXD设为1（01110011的第一位）一个时间宽度重复8次这个过程（每一次的TXD的值换到下一位）8次后发送1（将TXD设为1）表示结束 恭喜恭喜，串口通信也给我们造出来了，可以自己做一个串口了 不过再stc89c52rc中没这么麻烦，已经有现成的uart模块给我们使用了 串口中断的使用首先是串口初始化和定义 12345678910111213141516171819202122static void inituart()&#123; SCON = 0x50;\\\\串口工作模式 TMOD = 0x20;\\\\定时器工作模式 PCON = 0X80;\\\\波特率翻倍 TL1 = 0XF3;\\\\设定定时初值 TH1 = TL1; TR1 = 1;\\\\定时器溢出标志开 &#125;static void initinterrupt()&#123; IT0 = 1; EX0 = 1; ES = 1; EA = 1;&#125; 这个无需多言，注意波特率即可 发送函数代码 1234567891011121314void uarthander( unsigned char sibuffer ) &#123; SBUF = sibuffer; while(!TI); TI = 0;&#125;void updatehander( char* str )&#123; while(*str) &#123; uarthander(*str++); &#125;&#125; SBUF是缓存区，SBUF被赋值，串口助手就会输出这个值这个代码也挺简单的，SBUF一次只能赋一个值，我们使用updatehander函数实现输出字符串调用这个函数就可以输出字符串 接收函数代码 12345678910111213141516171819202122char recestring[10]; // 用于存储接收到的字符串，最大长度为10int i = 0; // 记录当前接收到的字符在 recestring 数组中的索引void comhander() interrupt 4&#123; if (RI) &#123; char w; w = SBUF; // 从串口缓冲区读取接收到的字符 recestring[i++] = w; // 将字符存储到 recestring 数组中，并更新索引 if (w == &#x27;\\n&#x27;) // 如果接收到换行符 &#x27;\\n&#x27;，表示接收到一条完整的字符串 &#123; recestring[i] = &#x27;\\0&#x27;; // 在字符串末尾添加 null 终止符，形成一个C风格字符串 updatehander(recestring); // 调用处理接收到字符串的函数 i = 0; // 重置索引，准备接收下一条字符串 &#125; RI = 0; // 清除接收中断标志位 TI = 0; // 清除发送中断标志位 &#125;&#125; 定义了一个数组，每一次都将接收到的值放在数组中直到值是换行符的时候才会将其视为完整的字符串我们将接收和发送函数分开，这样就可以处理更多问题 下面是我的示例工程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;REG52.H&gt; // 包含8051单片机的寄存器定义头文件sbit led1 = P2^4; // 定义 LED1 的引脚sbit led2 = P2^5; // 定义 LED2 的引脚sbit led3 = P2^6; // 定义 LED3 的引脚sbit led4 = P2^7; // 定义 LED4 的引脚static char sib[4], a, b, c, d; // 定义静态变量，用于存储串口接收的数据和数码管显示的数字void Delay(unsigned int xms)&#123; unsigned char i, j; while(xms--) &#123; i = 2; j = 239; do &#123; while (--j); &#125; while (--i); &#125;&#125;unsigned char NixieTable[] = &#123;0x03, 0x9F, 0x25, 0x0D, 0x99, 0x49, 0x41, 0x1F, 0x01, 0x09&#125;; // 数码管对应数字的表格void Nixie(unsigned char Location, Number)&#123; switch(Location) // 控制数码管的位置 &#123; case 1: P2 = 0x7; break; case 2: P2 = 0xB; break; case 3: P2 = 0xD; break; case 4: P2 = 0xE; break; &#125; P0 = NixieTable[Number]; // 显示对应数字 Delay(5); // 延时 P0 = ~0x0; // 关闭数码管&#125;static void inituart()&#123; SCON = 0x50; // 配置串口工作方式 TMOD = 0x20; // 配置计时器工作方式 PCON = 0X80; // 设置波特率倍增 TL1 = 0XF3; // 计时器1低位初始值 TH1 = TL1; // 计时器1高位初始值 TR1 = 1; // 启动计时器1&#125;static void initinterrupt()&#123; IT0 = 1; // 外部中断0触发方式为下降沿触发 EX0 = 1; // 允许外部中断0 ES = 1; // 允许串口中断 EA = 1; // 允许总中断&#125;void uarthander(unsigned char sibuffer) &#123; SBUF = sibuffer; // 将数据发送到串口缓冲区 while (!TI); // 等待发送完成 TI = 0; // 清除发送中断标志位&#125;void lightup(unsigned char byte)&#123; if(byte == 1) &#123; led1 = ~led1; // 切换 LED1 状态 &#125; if(byte == 2) &#123; led2 = ~led2; // 切换 LED2 状态 &#125; if(byte == 3) &#123; led3 = ~led3; // 切换 LED3 状态 &#125; if(byte == 4) &#123; led4 = ~led4; // 切换 LED4 状态 &#125;&#125;void updatehander(char* str)&#123; while(*str) &#123; uarthander(*str++); // 逐字符发送字符串到串口 &#125;&#125;void handergo() interrupt 0&#123; updatehander(&quot;Hello,World\\n&quot;); // 外部中断0触发时发送 &quot;Hello,World\\n&quot; 到串口&#125;unsigned char j = 0;static char w = &#x27;0&#x27;;void abcd()&#123; a = sib[0] - &#x27;0&#x27;; // 将字符转换为数字 b = sib[1] - &#x27;0&#x27;; // 将字符转换为数字 c = sib[2] - &#x27;0&#x27;; // 将字符转换为数字 d = sib[3] - &#x27;0&#x27;; // 将字符转换为数字&#125;void comhander() interrupt 4&#123; w = SBUF; // 从串口缓冲区读取接收到的字符 sib[j++] = w; // 存储接收到的字符 if(j &gt;= 4) &#123; j = 0; abcd(); // 处理接收到的字符，转换为数字 &#125; RI = 0; // 清除接收中断标志位 lightup(sib); // 控制LED状态&#125;void main()&#123; initinterrupt(); // 初始化中断 inituart(); // 初始化串口 while(1) &#123; Nixie(1, b); Nixie(2, c); Nixie(3, d); Nixie(4, a); // 循环显示数字到数码管 &#125;&#125; 这个代码完成了在串口助手输入4位数字，数码管显示这4位数字的功能简单吧，这就是内置uart的使用那么接下来，我们就得自己做一个串口了 模拟串口实际上就是根据uart协议的内容，自己写一个串口出来 前文已经详细的说明了流程 1.固定好时间间隔，也就是固定好波特率2.发送起始位3.根据数据发送数据的每一位4.发送结束位表示发送结束 话不多说，上代码！ 串口初始化 1234567891011121314151617181920212223242526272829sbit RXD2 = P3^0; // 定义串口接收引脚sbit TXD2 = P3^1; // 定义串口发送引脚unsigned char buffer[20]; // 存储接收到的数据unsigned char getnum = 0; // 接收数据的计数器void UartInit() // 串口初始化函数，波特率：4800bps @ 12.000MHz&#123; TMOD = 0x20; // 设置定时器模式 TH1 = 0x30; TL1 = 0x30; EA = 1; ET1 = 1; TF1 = 0; // 清除TF1标志 TR1 = 1; // 定时器1开始计时&#125;void uart() interrupt 3&#123; if (TR1 == 1)&#123; TH1 = 0x30; // 波特率4800bps TL1 = 0x30; // 定时器 TF1 = 0; &#125;&#125;void waittf()&#123; while (TF1 == 0);//定时器溢出做延迟 TF1 = 0;&#125; 发送函数 1234567891011121314151617181920212223242526void putdata(unsigned char str) &#123; int i = 8; str = str + str;//由于波特率误差，发送的AscII码会小一半所以我直接加一倍 TR1 = 1; TXD2 = 1; waittf(); while (i--) &#123; TXD2 = str &amp; 0x01; waittf(); str &gt;&gt;= 1; &#125; TXD2 = 0; waittf(); TR1 = 0;&#125;void putdatastr(unsigned char *str)&#123; while (*str) &#123; putdata(*str); // 发送字符串中的每个字符 str++; &#125;&#125; 由于波特率误差，发送的AscII码会小一半所以我直接加一倍首先赋值TXD2为1为起始位随后使用waitf函数做时间间隔使用&amp;0x01将值位赋值给TXD实现uart中的每一位数据位传输重复8次最后发送结束位 一样的道理，接收函数 1234567891011121314151617181920212223242526void getdata()&#123; unsigned char i = 0; unsigned char str = 0x0; if (RXD2 == 0) &#123; TR1 = 1; waittf(); while (i &lt; 8) &#123; str &gt;&gt;= 1; if (RXD2 == 1) &#123; str |= 0x80; &#125; waittf(); i++; &#125; buffer[getnum++] = str; // 存储接收到的数据 TR1 = 0; &#125; if(getnum == 20) &#123; getnum = 0; &#125;&#125; 监控RXD，只要为0立马开始赋值起始位、传数据位监控到RXD不为0就结束接收其余流程与发送函数原理相同 最后，附上main函数 12345678910111213141516171819202122232425262728293031323334353637383940414243void main()&#123; unsigned char i = 0; TXD2 = 0; // 初始化串口发送引脚 UartInit(); // 初始化串口 while (1) &#123; if(RXD2 == 0) &#123; int maxnum = 10; while (maxnum--) &#123; if (RXD2 == 0) &#123; getdata(); // 接收数据 maxnum = 10; &#125; &#125; &#125; else&#123; if(buffer[0] != 0) &#123; putdatastr(buffer); // 发送接收到的数据 for(i = 0; i &lt; 20; i++) &#123; if (buffer[i] != 0) &#123; buffer[i] = 0; &#125; else &#123; break; &#125; &#125; getnum = 0; putdata(0x0d); // 发送回车符 putdata(0x0a); // 发送换行符 &#125; &#125; &#125;&#125; 这样，就实现了自己做一个模拟串口，关键在于调波特率需要十分准确才可以正常传输数据在51大作业篇，我会详细写明模拟串口接收时会与其他中断冲突导致乱码，在这里不进行过多的讨论","categories":[],"tags":[{"name":"C51","slug":"C51","permalink":"http://blog.gavinccc.com/tags/C51/"},{"name":"C语言","slug":"C语言","permalink":"http://blog.gavinccc.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"keil","slug":"keil","permalink":"http://blog.gavinccc.com/tags/keil/"}]},{"title":"前端+","slug":"front_end","date":"2023-07-07T10:31:49.000Z","updated":"2024-02-26T08:38:12.947Z","comments":true,"path":"2023/07/07/front_end/","permalink":"http://blog.gavinccc.com/2023/07/07/front_end/","excerpt":"","text":"事件循环浏览器的进程模型何为进程？程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程 每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。 何为线程？有了进程后，就可以运行程序的代码了。 运行代码的「人」称之为「线程」。 一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。当主线程结束时，进程也相应结束 如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。 浏览器有哪些进程和线程？浏览器是一个多进程多线程的应用程序 浏览器内部工作极其复杂。 为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。 可以在浏览器的任务管理器中查看当前的所有进程 其中，最主要的进程有： 浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。 渲染进程（本节课重点讲解的进程） 渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。 将来该默认模式可能会有所改变，有兴趣的同学可参见chrome官方说明文档 渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面画 60 次 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考题：为什么渲染进程不适用多个线程来处理这些事情？ 要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？ 比如： 我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？ 我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？ 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？ …… 渲染主线程想出了一个绝妙的主意来处理这个问题：排队 在最开始的时候，渲染主线程会进入一个无限循环 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务 这样一来，就可以让每个任务有条不紊的、持续的进行下去了。 整个过程，被称之为事件循环（消息循环） 若干解释何为异步？代码在执行过程中，会遇到一些无法立即处理的任务，比如： 计时完成后需要执行的任务 —— setTimeout、setInterval 网络通信完成后需要执行的任务 – XHR、Fetch 用户操作后需要执行的任务 – addEventListener 如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」 渲染主线程承担着极其重要的工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 JS 的异步？ 参考答案： JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。 JS为何会阻碍渲染？先看代码 1234567891011121314151617&lt;h1&gt;Mr.Yuan is awesome!&lt;/h1&gt;&lt;button&gt;change&lt;/button&gt;&lt;script&gt; var h1 = document.querySelector(&#x27;h1&#x27;); var btn = document.querySelector(&#x27;button&#x27;); // 死循环指定的时间 function delay(duration) &#123; var start = Date.now(); while (Date.now() - start &lt; duration) &#123;&#125; &#125; btn.onclick = function () &#123; h1.textContent = &#x27;陈广文很帅！&#x27;; delay(3000); &#125;;&lt;/script&gt; 点击按钮后，会发生什么呢？ &lt;见具体演示&gt; 任务有优先级吗？任务没有优先级，在消息队列中先进先出 但消息队列是有优先级的 根据 W3C 的最新解释: 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法 在目前 chrome 的实现中，至少包含了下面的队列： 延时队列：用于存放计时器到达后的回调任务，优先级「中」 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」 微队列：用户存放需要最快执行的任务，优先级「最高」 添加任务到微队列的主要方式主要是使用 Promise、MutationObserver 例如： 12// 立即把一个函数添加到微队列Promise.resolve().then(函数) 浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑 面试题：阐述一下 JS 的事件循环 参考答案： 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 中的计时器能做到精确计时吗？为什么？ 参考答案： 不行，因为： 计算机硬件没有原子钟，无法做到精确计时 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差 浏览器渲染过程浏览器是如何渲染页面的？当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是解析 HTML。 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。 css与js是完全不同的 如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的下一步是样式计算。 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是布局，布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分时候，DOM 树和布局树并非一一对应。 比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是分层 主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。 再下一步是绘制 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 再来是分块 完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 它会从线程池中拿取多个线程来完成分块工作。 分块完成后，进入光栅化阶段。 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图 最后一个阶段就是画了 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 完整流程 什么是 reflow？reflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 什么是 repaint？repaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。 为什么 transform 的效率高？因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。 CSS 之包含块 上文说到布局树的几何计算会算出css包含块，以下是css包含块的详细解释 一说到 CSS 盒模型，这是很多小伙伴耳熟能详的知识，甚至有的小伙伴还能说出 border-box 和 content-box 这两种盒模型的区别。 但是一说到 CSS 包含块，有的小伙伴就懵圈了，什么是包含块？好像从来没有听说过这玩意儿。 好吧，如果你对包含块的知识一无所知，那么系好安全带，咱们准备出发了。 包含块英语全称为containing block，实际上平时你在书写 CSS 时，大多数情况下你是感受不到它的存在，因此你不知道这个知识点也是一件很正常的事情。但是这玩意儿是确确实实存在的，在 CSS 规范中也是明确书写了的： https://drafts.csswg.org/css2/#containing-block-details 并且，如果你不了解它的运作机制，有时就会出现一些你认为的莫名其妙的现象。 那么，这个包含块究竟说了什么内容呢？ 说起来也简单，就是元素的尺寸和位置，会受它的包含块所影响。对于一些属性，例如 width, height, padding, margin，绝对定位元素的偏移值（比如 position 被设置为 absolute 或 fixed），当我们对其赋予百分比值时，这些值的计算值，就是通过元素的包含块计算得来。 来吧，少年，让我们从最简单的 case 开始看。 12345&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910.container&#123; width: 500px; height: 300px; background-color: skyblue;&#125;.item&#123; width: 50%; height: 50%; background-color: red;&#125; 请仔细阅读上面的代码，然后你认为 div.item 这个盒子的宽高是多少？ 相信你能够很自信的回答这个简单的问题，div.item 盒子的 width 为 250px，height 为 150px。 这个答案确实是没有问题的，但是如果我追问你是怎么得到这个答案的，我猜不了解包含块的你大概率会说，因为它的父元素 div.container 的 width 为 500px，50% 就是 250px，height 为 300px，因此 50% 就是 150px。 这个答案实际上是不准确的。正确的答案应该是，div.item 的宽高是根据它的包含块来计算的，而这里包含块的大小，正是这个元素最近的祖先块元素的内容区。 因此正如我前面所说，很多时候你都感受不到包含块的存在。 包含块分为两种，一种是根元素（HTML 元素）所在的包含块，被称之为初始包含块（initial containing block）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。 另外一种是对于非根元素，对于非根元素的包含块判定就有几种不同的情况了。大致可以分为如下几种： 如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。 如果 position 属性是 fixed，那么包含块由视口建立。 如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。 前面两条实际上都还比较好理解，第三条往往是初学者容易比较忽视的，我们来看一个示例： 1234567&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;item2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; 1234567891011121314151617181920.container &#123; width: 500px; height: 300px; background-color: skyblue; position: relative;&#125;.item &#123; width: 300px; height: 150px; border: 5px solid; margin-left: 100px;&#125;.item2 &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 10px; top: 10px;&#125; 首先阅读上面的代码，然后你能在脑海里面想出其大致的样子么？或者用笔和纸画一下也行。 公布正确答案： 怎么样？有没有和你所想象的对上？ 其实原因也非常简单，根据上面的第三条规则，对于 div.item2 来讲，它的包含块应该是 div.container，而非 div.item。 如果你能把上面非根元素的包含块判定规则掌握，那么关于包含块的知识你就已经掌握 80% 了。 实际上对于非根元素来讲，包含块还有一种可能，那就是如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的： transform 或 perspective 的值不是 none will-change 的值是 transform 或 perspective filter 的值不是 none 或 will-change 的值是 filter(只在 Firefox 下生效). contain 的值是 paint (例如: contain: paint;) 我们还是来看一个示例： 1234567&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt; &lt;div class=&quot;item2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 123456789101112131415161718192021.container &#123; width: 500px; height: 300px; background-color: skyblue; position: relative;&#125;.item &#123; width: 300px; height: 150px; border: 5px solid; margin-left: 100px; transform: rotate(0deg); /* 新增代码 */&#125;.item2 &#123; width: 100px; height: 100px; background-color: red; position: absolute; left: 10px; top: 10px;&#125; 我们对于上面的代码只新增了一条声明，那就是 transform: rotate(0deg)，此时的渲染效果却发生了改变，如下图所示： 可以看到，此时对于 div.item2 来讲，包含块就变成了 div.item。 好了，到这里，关于包含块的知识就基本讲完了。 我们再把 CSS 规范中所举的例子来看一下。 123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;Illustration of containing blocks&lt;/title&gt; &lt;/head&gt; &lt;body id=&quot;body&quot;&gt; &lt;div id=&quot;div1&quot;&gt; &lt;p id=&quot;p1&quot;&gt;This is text in the first paragraph...&lt;/p&gt; &lt;p id=&quot;p2&quot;&gt; This is text &lt;em id=&quot;em1&quot;&gt; in the &lt;strong id=&quot;strong1&quot;&gt;second&lt;/strong&gt; paragraph. &lt;/em&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面是一段简单的 HTML 代码，在没有添加任何 CSS 代码的情况下，你能说出各自的包含块么？ 对应的结果如下： 元素 包含块 html initial C.B. (UA-dependent) body html div1 body p1 div1 p2 div1 em1 p2 strong1 p2 首先 HTML 作为根元素，对应的包含块就是前面我们所说的初始包含块，而对于 body 而言，这是一个 static 定位的元素，因此该元素的包含块参照第一条为 html，以此类推 div1、p1、p2 以及 em1 的包含块也都是它们的父元素。 不过 strong1 比较例外，它的包含块确实 p2，而非 em1。为什么会这样？建议你再把非根元素的第一条规则读一下： 如果元素的 positiion 是 relative 或 static ，那么包含块由离它最近的块容器（block container）的内容区域（content area）的边缘建立。 没错，因为 em1 不是块容器，而包含块是离它最近的块容器的内容区域，所以是 p2。 接下来添加如下的 CSS： 1234#div1 &#123; position: absolute; left: 50px; top: 50px &#125; 上面的代码我们对 div1 进行了定位，那么此时的包含块会发生变化么？你可以先在自己思考一下。 答案如下： 元素 包含块 html initial C.B. (UA-dependent) body html div1 initial C.B. (UA-dependent) p1 div1 p2 div1 em1 p2 strong1 p2 可以看到，这里 div1 的包含块就发生了变化，变为了初始包含块。这里你可以参考前文中的这两句话： 初始包含块（initial containing block）。对于浏览器而言，初始包含块的的大小等于视口 viewport 的大小，基点在画布的原点（视口左上角）。它是作为元素绝对定位和固定定位的参照物。 如果元素使用了 absolute 定位，则包含块由它的最近的 position 的值不是 static （也就是值为fixed、absolute、relative 或 sticky）的祖先元素的内边距区的边缘组成。 是不是一下子就理解了。没错，因为我们对 div1 进行了定位，因此它会应用非根元素包含块计算规则的第三条规则，寻找离它最近的 position 的值不是 static 的祖先元素，不过显然 body 的定位方式为 static，因此 div1 的包含块最终就变成了初始包含块。 接下来我们继续修改我们的 CSS： 12345678910#div1 &#123; position: absolute; left: 50px; top: 50px &#125;#em1 &#123; position: absolute; left: 100px; top: 100px &#125; 这里我们对 em1 同样进行了 absolute 绝对定位，你想一想会有什么样的变化？ 没错，聪明的你大概应该知道，em1 的包含块不再是 p2，而变成了 div1，而 strong1 的包含块也不再是 p2 了，而是变成了 em1。 如下表所示： 元素 包含块 html initial C.B. (UA-dependent) body html div1 initial C.B. (UA-dependent) p1 div1 p2 div1 em1 div1（因为定位了，参阅非根元素包含块确定规则的第三条） strong1 em1（因为 em1 变为了块容器，参阅非根元素包含块确定规则的第一条） 好了，这就是 CSS 规范中所举的例子。如果你全都能看明白，以后你还能跟别人说你是看过这一块知识对应的 CSS 规范的人。 另外，关于包含块的知识，在 MDN 上除了解说了什么是包含块以外，也举出了很多简单易懂的示例。 具体你可以移步到：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Containing_block 好了，这就是有关包含块的所有内容了，你学会了么？-） -EOF- CSS 属性计算过程你是否了解 CSS 的属性计算过程呢？ 有的同学可能会讲，CSS属性我倒是知道，例如： 123p&#123; color : red;&#125; 上面的 CSS 代码中，p 是元素选择器，color 就是其中的一个 CSS 属性。 但是要说 CSS 属性的计算过程，还真的不是很清楚。 没关系，通过此篇文章，能够让你彻底明白什么是 CSS 属性的计算流程。 首先，不知道你有没有考虑过这样的一个问题，假设在 HTML 中有这么一段代码： 123&lt;body&gt; &lt;h1&gt;这是一个h1标题&lt;/h1&gt;&lt;/body&gt; 上面的代码也非常简单，就是在 body 中有一个 h1 标题而已，该 h1 标题呈现出来的外观是如下： 目前我们没有设置该 h1 的任何样式，但是却能看到该 h1 有一定的默认样式，例如有默认的字体大小、默认的颜色。 那么问题来了，我们这个 h1 元素上面除了有默认字体大小、默认颜色等属性以外，究竟还有哪些属性呢？ 答案是该元素上面会有 CSS 所有的属性。你可以打开浏览器的开发者面板，选择【元素】，切换到【计算样式】，之后勾选【全部显示】，此时你就能看到在此 h1 上面所有 CSS 属性对应的值。 换句话说，我们所书写的任何一个 HTML 元素，实际上都有完整的一整套 CSS 样式。这一点往往是让初学者比较意外的，因为我们平时在书写 CSS 样式时，往往只会书写必要的部分，例如前面的： 123p&#123; color : red;&#125; 这往往会给我们造成一种错觉，认为该 p 元素上面就只有 color 属性。而真实的情况确是，任何一个 HTML 元素，都有一套完整的 CSS 样式，只不过你没有书写的样式，大概率可能会使用其默认值。例如上图中 h1 一个样式都没有设置，全部都用的默认值。 但是注意，我这里强调的是“大概率可能”，难道还有我们“没有设置值，但是不使用默认值”的情况么？ 嗯，确实有的，所以我才强调你要了解“CSS 属性的计算过程”。 总的来讲，属性值的计算过程，分为如下这么 4 个步骤： 确定声明值 层叠冲突 使用继承 使用默认值 确定声明值首先第一步，是确定声明值。所谓声明值就是作者自己所书写的 CSS 样式，例如前面的： 123p&#123; color : red;&#125; 这里我们声明了 p 元素为红色，那么就会应用此属性设置。 当然，除了作者样式表，一般浏览器还会存在“用户代理样式表”，简单来讲就是浏览器内置了一套样式表。 在上面的示例中，作者样式表中设置了 color 属性，而用户代理样式表（浏览器提供的样式表）中设置了诸如 display、margin-block-start、margin-block-end、margin-inline-start、margin-inline-end 等属性对应的值。 这些值目前来讲也没有什么冲突，因此最终就会应用这些属性值。 层叠冲突在确定声明值时，可能出现一种情况，那就是声明的样式规则发生了冲突。 此时会进入解决层叠冲突的流程。而这一步又可以细分为下面这三个步骤： 比较源的重要性 比较优先级 比较次序 来来来，我们一步一步来看。 比较源的重要性当不同的 CSS 样式来源拥有相同的声明时，此时就会根据样式表来源的重要性来确定应用哪一条样式规则。 那么问题来了，咱们的样式表的源究竟有几种呢？ 整体来讲有三种来源： 浏览器会有一个基本的样式表来给任何网页设置默认样式。这些样式统称用户代理样式。 网页的作者可以定义文档的样式，这是最常见的样式表，称之为页面作者样式。 浏览器的用户，可以使用自定义样式表定制使用体验，称之为用户样式。 对应的重要性顺序依次为：页面作者样式 &gt; 用户样式 &gt; 用户代理样式 更详细的来源重要性比较，可以参阅 MDN：https://developer.mozilla.org/zh-CN/docs/Web/CSS/Cascade 我们来看一个示例。 例如现在有页面作者样式表和用户代理样式表中存在属性的冲突，那么会以作者样式表优先。 1234p&#123; color : red; display: inline-block;&#125; 可以明显的看到，作者样式表和用户代理样式表中同时存在的 display 属性的设置，最终作者样式表干掉了用户代理样式表中冲突的属性。这就是第一步，根据不同源的重要性来决定应用哪一个源的样式。 比较优先级那么接下来，如果是在在同一个源中有样式声明冲突怎么办呢？此时就会进行样式声明的优先级比较。 例如： 123&lt;div class=&quot;test&quot;&gt; &lt;h1&gt;test&lt;/h1&gt;&lt;/div&gt; 1234567.test h1&#123; font-size: 50px;&#125;h1 &#123; font-size: 20px;&#125; 在上面的代码中，同属于页面作者样式，源的重要性是相同的，此时会以选择器的权重来比较重要性。 很明显，上面的选择器的权重要大于下面的选择器，因此最终标题呈现为 50px。 可以看到，落败的作者样式在 Elements&gt;Styles 中会被划掉。 有关选择器权重的计算方式，不清楚的同学，可以进入此传送门：https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity 比较次序经历了上面两个步骤，大多数的样式声明能够被确定下来。但是还剩下最后一种情况，那就是样式声明既是同源，权重也相同。 此时就会进入第三个步骤，比较样式声明的次序。 举个例子： 1234567h1 &#123; font-size: 50px;&#125;h1 &#123; font-size: 20px;&#125; 在上面的代码中，同样都是页面作者样式，选择器的权重也相同，此时位于下面的样式声明会层叠掉上面的那一条样式声明，最终会应用 20px 这一条属性值。 至此，样式声明中存在冲突的所有情况，就全部被解决了。 使用继承层叠冲突这一步完成后，解决了相同元素被声明了多条样式规则究竟应用哪一条样式规则的问题。 那么如果没有声明的属性呢？此时就使用默认值么？ No、No、No，别急，此时还有第三个步骤，那就是使用继承而来的值。 例如： 123&lt;div&gt; &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt;&lt;/div&gt; 123div &#123; color: red;&#125; 在上面的代码中，我们针对 div 设置了 color 属性值为红色，而针对 p 元素我们没有声明任何的属性，但是由于 color 是可以继承的，因此 p 元素从最近的 div 身上继承到了 color 属性的值。 这里有两个点需要同学们注意一下。 首先第一个是我强调了是最近的 div 元素，看下面的例子： 12345&lt;div class=&quot;test&quot;&gt; &lt;div&gt; &lt;p&gt;Lorem ipsum dolor sit amet.&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456div &#123; color: red;&#125;.test&#123; color: blue;&#125; 因为这里并不涉及到选中 p 元素声明 color 值，而是从父元素上面继承到 color 对应的值，因此这里是谁近就听谁的，初学者往往会产生混淆，又去比较权重，但是这里根本不会涉及到权重比较，因为压根儿就没有选中到 p 元素。 第二个就是哪些属性能够继承？ 关于这一点的话，大家可以在 MDN 上面很轻松的查阅到。例如我们以 text-align 为例，如下图所示： 使用默认值好了，目前走到这一步，如果属性值都还不能确定下来，那么就只能是使用默认值了。 如下图所示： 前面我们也说过，一个 HTML 元素要在浏览器中渲染出来，必须具备所有的 CSS 属性值，但是绝大部分我们是不会去设置的，用户代理样式表里面也不会去设置，也无法从继承拿到，因此最终都是用默认值。 好了，这就是关于 CSS 属性计算过程的所有知识了。 一道面试题好了，学习了今天的内容，让我来用一道面试题测试测试大家的理解程度。 下面的代码，最终渲染出来的效果，a 元素是什么颜色？p 元素又是什么颜色？ 1234&lt;div&gt; &lt;a href=&quot;&quot;&gt;test&lt;/a&gt; &lt;p&gt;test&lt;/p&gt;&lt;/div&gt; 123div &#123; color: red;&#125; 大家能说出为什么会呈现这样的结果么？ 解答如下： 实际上原因很简单，因为 a 元素在用户代理样式表中已经设置了 color 属性对应的值，因此会应用此声明值。而在 p 元素中无论是作者样式表还是用户代理样式表，都没有对此属性进行声明，然而由于 color 属性是可以继承的，因此最终 p 元素的 color 属性值通过继承来自于父元素。 你答对了么？-） -EOF-","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://blog.gavinccc.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://blog.gavinccc.com/tags/css/"},{"name":"前端","slug":"前端","permalink":"http://blog.gavinccc.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://blog.gavinccc.com/tags/js/"}]}],"categories":[],"tags":[{"name":"pytorch","slug":"pytorch","permalink":"http://blog.gavinccc.com/tags/pytorch/"},{"name":"nccl","slug":"nccl","permalink":"http://blog.gavinccc.com/tags/nccl/"},{"name":"yolo","slug":"yolo","permalink":"http://blog.gavinccc.com/tags/yolo/"},{"name":"linux","slug":"linux","permalink":"http://blog.gavinccc.com/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://blog.gavinccc.com/tags/ubuntu/"},{"name":"ros","slug":"ros","permalink":"http://blog.gavinccc.com/tags/ros/"},{"name":"VScode","slug":"VScode","permalink":"http://blog.gavinccc.com/tags/VScode/"},{"name":"Embedded IDE","slug":"Embedded-IDE","permalink":"http://blog.gavinccc.com/tags/Embedded-IDE/"},{"name":"VUE","slug":"VUE","permalink":"http://blog.gavinccc.com/tags/VUE/"},{"name":"ElementUI","slug":"ElementUI","permalink":"http://blog.gavinccc.com/tags/ElementUI/"},{"name":"yarn","slug":"yarn","permalink":"http://blog.gavinccc.com/tags/yarn/"},{"name":"node.js","slug":"node-js","permalink":"http://blog.gavinccc.com/tags/node-js/"},{"name":"npm","slug":"npm","permalink":"http://blog.gavinccc.com/tags/npm/"},{"name":"html","slug":"html","permalink":"http://blog.gavinccc.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://blog.gavinccc.com/tags/css/"},{"name":"3D建模","slug":"3D建模","permalink":"http://blog.gavinccc.com/tags/3D%E5%BB%BA%E6%A8%A1/"},{"name":"C51","slug":"C51","permalink":"http://blog.gavinccc.com/tags/C51/"},{"name":"C语言","slug":"C语言","permalink":"http://blog.gavinccc.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"keil","slug":"keil","permalink":"http://blog.gavinccc.com/tags/keil/"},{"name":"前端","slug":"前端","permalink":"http://blog.gavinccc.com/tags/%E5%89%8D%E7%AB%AF/"},{"name":"js","slug":"js","permalink":"http://blog.gavinccc.com/tags/js/"}]}